<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>[Lua5.4.4源码].GC | frog&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="lua源码GC分析">
<meta name="author" content="
作者:&nbsp;frog">
<link rel="canonical" href="https://frog-game.github.io/posts/read/lua5.4.4.gc/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8b75bf56d6fb0c429b5f3ce03bce19c9ef1e90cc024b64bd12ec321c68cca894.css" integrity="sha256-i3W/Vtb7DEKbXzzgO84Zye8ekMwCS2S9EuwyHGjMqJQ=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
        onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://frog-game.github.io/img/Q.gif">
<link rel="icon" type="image/png" sizes="16x16" href="https://frog-game.github.io/img/Q.gif">
<link rel="icon" type="image/png" sizes="32x32" href="https://frog-game.github.io/img/Q.gif">
<link rel="apple-touch-icon" href="https://frog-game.github.io/img/Q.gif">
<link rel="mask-icon" href="https://frog-game.github.io/img/Q.gif">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = ""; 
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<meta property="og:title" content="[Lua5.4.4源码].GC" />
<meta property="og:description" content="lua源码GC分析" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://frog-game.github.io/posts/read/lua5.4.4.gc/" />
<meta property="og:image" content="https://frog-game.github.io/posts/read/lua5.4.4.gc/image-20230220004042802.png" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-20T01:30:29&#43;08:00" />
<meta property="article:modified_time" content="2023-02-20T01:30:29&#43;08:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://frog-game.github.io/posts/read/lua5.4.4.gc/image-20230220004042802.png" />
<meta name="twitter:title" content="[Lua5.4.4源码].GC"/>
<meta name="twitter:description" content="lua源码GC分析"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "📚文章",
      "item": "https://frog-game.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "📕 阅读",
      "item": "https://frog-game.github.io/posts/read/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "[Lua5.4.4源码].GC",
      "item": "https://frog-game.github.io/posts/read/lua5.4.4.gc/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "[Lua5.4.4源码].GC",
  "name": "[Lua5.4.4源码].GC",
  "description": "lua源码GC分析",
  "keywords": [
    ""
  ],
  "articleBody": "GC由来简介 c,c++的话基本都是手动管理内存,优点是效率很高,毕竟不需要去找出那些是垃圾,需要被清理这种逻辑处理,也不需要在gc清理的时候,把主线程暂停,等等操作造成卡顿,但是这种手动管理的也有一定的问题,那就是内存碎片,还有内存重复复用,所以会利用内存池管理这种技术来尽量规避这种情况\n比如不使用内存池分配技术,只使用Malloc,free申请空间就很容易造成如下图的内存碎片\n内碎片\n内碎片是已经被分配出去的内存[进程已经拿到手上了],但是进程已经利用不上了\n如下图,当时进程我需要申请了14KB的内存,然后因为linux伙伴算法导致返回了16KB内存,因为伙伴算法是按接近最大的2的幂返回内存空间,导致了2KB的冗余,因为这2KB非常小,很有可能内部进程使用不到,如果一直这样请求,就会导致了很多细小的不连续的内部休闲空间[碎片],当内部进程需要分配一大片连续的内存的时候,即使有很多细小的空间组合起来能大于需要申请的空间,但是因为不连续也就无能为力,不能满足要求,这样就造成了内碎片\n外碎片\n外部碎片指的是还没有被分配出去[进程还没有拿到手],但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。\n主要原因还是频繁的申请释放导致了外碎片的存在\n如下图我开始申请了16KB的资源,然后又申请了16KB的,这个时候把我第一块的16KB给free掉,他就不属于任何进程,然后进程又来了许多个请求,一直需要18KB的内存,因为第一块只有16KB,而且因为伙伴算法的释放规则是相邻的地址才能进行合并释放,但是第2块内存一直被进程占着,所以第一块和第二块也合并不了,一直利用不上,导致了外碎片的存在\n为了解决外碎片linux使用了伙伴算法\n为了解决内碎片linux使用了slab算法,其实slab算法内部实现就是一个内存池逻辑结构\n利用上面的办法虽然对内存的管控已经几乎完美,但是因为还是程序员直接内存裸操纵,还是难以避免开发的时候,造成内存的崩溃,野指针,内存泄露,溢出,各种异常问题,于是为了解决这些问题,同时提升开发效率,不用程序员太关心内存处理,于是就有了现在的GC机制[智能指针是另外一回事]\n现在有了GC机制,但是内部没有合理的回收机制释放管理这些内存空间,比如如果因为申请和释放规则的不合理,一直申请内存,缓慢释放内存,就有可能造成像人一样吃的太饱,撑的不行,导致人思维缓慢(垃圾不需要内存过多,机器查找需要的内存查找不过来),甚至撑死(再也没有内存申请挂了 撑死的时候不一定会产生coredump文件)\n题外话为什么不一定产生coredump文件\n\u003e`dump`文件只有在程序崩溃时才会生成,如果程序没有奔溃,那么可能是如下情况导致 \u003e \u003e主要是因为`linux`有一个叫做`OOM-killer(Out Of Memory killer)`的机制,`OOM killer`会 在系统内存耗尽的情况下触发,选择性的干掉一些进程,以求释放一些内存 \u003e \u003e当发生这种崩了,但是没有产生`coredump`的情况,可以去系统日志文件`/var/log/messages`看看里面 有没有相关日志记录,你是因为被`OOM-killer`机制给杀掉了进程 总之一句话来说:GC主要解决的就是内存过多,怎么合理回收垃圾内存的这些事儿\nGC怎么回收内存 LuaGC,java gc等等其他语言GC发展历史就不详细描述了,主要还是讲讲Lua5.4GC回收原理\n主要有两种一种是分代GC,一种是增量GC\n能被GC回收的对象 union GCUnion { GCObject gc; /* common header */ struct TString ts;//字符串 struct Udata u;//用户数据 union Closure cl;//闭包 struct Table h;//表 struct Proto p;//函数原型:存放函数字节码信息 struct lua_State th; /* thread *///线程 struct UpVal upv;//上值 }; 关于回收对象更详细的一些内容在这里就不详细的叙述了,想要了解的可以去我的博客下面地址了解\nGC对象\n颜色处理 从上图中我们可以看出lua为了效率和内存着想用的是一个字节8个bit位之间的相互作用来标识颜色,和分代GC的年龄情况\n颜色bit位索引 颜色 简介 宏运算 二进制 注解 WHITE0BIT 3 白0 bitmask(3) 1000 bit第3位设置成1 WHITE1BIT 4 白1 bitmask(4) 10000 bit第4位设置成1 BLACKBIT 5 黑色 bitmask(5) 100000 bit第5位设置成1 FINALIZEDBIT 6 用于标记userdata bitmask(6) 1000000 bit第6位设置成1 WHITEBITS 白色 bit2mask(WHITE0BIT, WHITE1BIT) 11000 bit第3,4位设置成1 为啥lua5.4要把白色分成两个标识呢,主要是因为如果对象在GC标记阶段之后创建对象,这个时候假如只有一个白色标识位,那么新创建的对象就会设置成白色,设置成功以后接下来到了回收阶段,因为白色是表示可回收的,那么新创建的对象会被认为没有引用而被删除了,这个逻辑肯定是不对的,不合理是的\n所以为了解决这种不合理情况lua创造了白0 白1两种状态来进行乒乓切换,其实也就是当前白和非当前白状态的乒乓切换\n特别注意并没有固定设置白0就是当前白,白1就是非当前白,是不是当前白是由当前GC使用的白色是啥决定\n当GC来到了回收阶段的时候,如果发现对象标识的颜色不是当前白,那么就会认为是没有引用而直接回收,而刚标识阶段和回收阶段之间创建的对象是当前白,就不会参与这次``GC回收,而到下一次GC回收才回收掉,毕竟因为乒乓切换,当前白到下一次GC`也会变成其它白状态\n颜色bit位检测 iswhite(x) 是不是白色 如果bit位第 3,4位中任意一位是1那么就认为他是白色标识\nisblack(x) 是不是黑色 如果bit位第5位是1,那么就认为是黑色标识\nisgray(x) 是不是灰色 如果bit位第3,4,,5位都是0,那么就认为是灰色标识\ntofinalize(x)是不是标识了userdata 如果bit位第6位是1,那么就认为标识了userdata,注意并没有红色颜色这个标识,只是我为了区分其他颜色涂上的\n主要还是userdata类型不同于其他类型,用户可以自己传入数据,设置gc元方法,自定义释放内存,所以 当 userdata 确认不被引用,则设置上这个标记,后面统一管理释放资源\n黑色,白色位控制 注意到白色位是乒乓效应的,也就是3,4号位是互斥状态\notherwhite(g) 非当前白 宏公式((g)-\u003ecurrentwhite ^ WHITEBITS)\n表示非当前GC将要回收的白色类型 比如\n如果(g)-\u003ecurrentwhite是1000 1000 ^ 11000 = 10000\n如果(g)-\u003ecurrentwhite的值是10000的话, 10000 ^ 11000 = 1000\n结果正好相反\nluaC_white(g) 当前白 宏公式cast_byte((g)-\u003ecurrentwhite \u0026 WHITEBITS)\n表示得到当前的要回收的白色类型 比如\n如果(g)-\u003ecurrentwhite是1000 1000 \u0026 11000 = 01000, 1000 \u0026 11000还是1000\n如果(g)-\u003ecurrentwhite是10000 10000 \u0026 11000 = 10000, 10000 \u002611000还是10000\nchangewhite(x) 改变当前白色位 宏公式((x)-\u003emarked ^= WHITEBITS) 比如如果现在((x)-\u003emarked是101000\n这个时候执行了一下changewhite(x) 101000 ^ 11000 = 110000 因为是异或逻辑\n0和任何数异或是本身\n1和任何数异或是他相反的bit位\n所以我们得到了如下图结果\n比如如果现在((x)-\u003emarked是110000\n这个时候执行了一下changewhite(x) 110000 ^ 11000 = 101000 因为是异或逻辑\n0和任何数异或是本身\n1和任何数异或是他相反的bit位\n所以我们得到了如下图结果\nnw2black(x) 设置成黑色 当bit 3,4位都是0然后就可以设成把5号位设置成黑色了\n颜色是否可被回收 颜色 状态 当前GC回收阶段是否回收 当前白 下次GC回收状态 不回收 其他白 回收状态 回收 灰色 当前对象为待标记状态 不回收 黑色 当前对象为已标记状态 不回收 年龄处理 年龄bit位索引 age使用的位mask,age只使用了marked的0,1,2位置\n青年对象\n宏定义 二进制 注解 G_NEW 0 000 本次cycle创建的新对象(没有引用任何old对象) G_SURVIVAL 1 001 当前gc存活下来的对象 G_OLD0 2 010 当前gc循环被barrier forward的节点,如果被插入的节点为isold()为true的节点 老年对象\n宏定义 二进制 注解 G_OLD1 3 011 活过了一次完整的gc G_OLD 4 100 活过了两次完整的gc,标记为G_OLD,不再被访问 G_TOUCHED1 5 101 old节点被插入新节点 G_TOUCHED2 6 110 G_TOUCHED1节点经过一次完整的gc还没有新的节点插入 getage(o) 获取年龄 宏公式((o)-\u003emarked \u0026 AGEBITS)\n主要是利用了和#define AGEBITS 7 也就是二进制111的与运算得到当前的年龄毕竟与运算逻辑是\n1 \u0026 1 = 1 0 \u0026 1 = 0 等价于留下了低3位的数据\nsetage(o,a) 设置年龄 宏公式((o)-\u003emarked = cast_byte(((o)-\u003emarked \u0026 (~AGEBITS)) | a))\n~AGEBITS 等价于低3位是000 其他位都是1 比如64位系统得到结果是这样\n1111111111111111111111111111111111111111111111111111111111111000\n(o)-\u003emarked \u0026 (~AGEBITS)) 进行与运算以后等价于高3位以上都会留下来毕竟与运算逻辑是\n1 \u0026 1 = 1 0 \u0026 1 = 0 (o)-\u003emarked \u0026 (~AGEBITS)) | a\n然后和a进行或运算,这个就等价于进行或运算的组合逻辑了 毕竟或运算逻辑\n0 | 0 = 0\n0 | 1 = 1\n1 | 0 = 1\n1 | 1 = 1\nchangeage(o,f,t) 改变年龄 宏公式check_exp(getage(o) == (f), (o)-\u003emarked ^= ((f)^(t)))\n从f变到t 前提是o的年龄要等于f 举个例子changeage(curr, G_TOUCHED1, G_TOUCHED2) 如果getage(o) == (f) 那么marked的低3位是101 101^=(101^110) ,101^=011 o-\u003emarked=110 也就等价与o-\u003emarked从101变到了110\n这个公式是lua作者利用对同一个值进行两次异或等于本身原理来达到这样的效果\n0 ⊕ x = x\n1 ⊕ x = x'(x'表示取反)\nx ⊕ x = 0\n所以有 y ⊕ x ⊕ x = y\n增量GC 经过前面的叙述,我们能知道Lua 增量GC使用的是4色标记清除算法\n当前白:表示本轮GC不会被回收的对象,也是对象开始创建时候的初始状态 其他白:表示本轮GC要被回收的对象,这个白一般都是上轮GC留下来的旧白,也可以认为这个白已经没有引用任何对象了 灰色:表示本来GC对象引用的其他对象还没有被访问到,需要进行扫描标记 黑色:表示本来GC对象引用的其他对象都已经被访问过了 增量GC时候存放GCobject的链表 lua本身有一个global_State的全局状态机,这里存着需要被GC流程处理的数据,大概如下所示\ntypedef struct global_State { GCObject *allgc; GCObject **sweepgc; GCObject *finobj; GCObject *gray; GCObject *grayagain; GCObject *weak; GCObject *ephemeron; GCObject *allweak; GCObject *tobefnz; GCObject *fixedgc; struct lua_State *twups; } 链表 作用 allgc 存放待GC对象的链表,所有对象创建之后都会放入该链表中 sweepgc 由于回收阶段不是一次性全部回收这个链表的所有数据\n所以使用这个变量来保存当前回收的位置,下一次从这个位置开始继续回收操作 finobj 存放所有带有析构函数(__gc)的GC obj链表 gray 存放灰色节点的链表 grayagain 存放需要一次性扫描处理的灰色节点链表,也就是说,这个链表上所有数据的处理需要一步到位\n不能被打断 weak 存放弱值的链表 ephemeron 键值对(pair),键是弱引用,但键对值的 mark 有如下影响\n如果键可达(reachable),则 mark 其值\n如果键不可达,则不必 mark 其值\n主要用来解决弱表的循环引用问题 弱引用(weak reference):可以访问对象,但不会阻止对象被收集\n弱表(weak table):键或(和)值是弱引用 allweak 具有要清除的弱键或弱值 或者弱键弱值同时存在的表 tobefnz 所有准备终结的userdata对象 fixedgc 永远不回收的对象链表, 如保留关键字的字符串, 对象必须在创建之后马上\n从 allgc 链表移入该链表中, 用的是 lgc.c 中的 luaC_fix 函数 twups 所有带有open upvalue 的 thread 都会放到这个链表中\n这样提供了一个方便的遍历 thread 的途径\n并且排除掉了没有 open upvalue 的 thread 增量GC流程 上图是增量GC的简易流程图,每个步骤关键的函数,我也画在了上面,大家先初步了解,能有一个大概印象,接下来我将详细的讲解里面的弯弯绕绕,细节部分\n新建对象阶段 从上图我们可以看到\n在创建一个新的GC类型的对象的时候,它都会把当前GC的颜色标识设置成当前白 并且还会把用头插法的方法,将新创建的对象 放入全局状态机的allgc链表当中,这其实也透露出因为用了头插法,所以我们在GC扫描的时候能优先扫描新创建的对象,需要接下来被GC待扫描处理的对象都会存在这个里面 GC触发阶段 自动触发 自动触发:luaC_checkGC,checkGC\n我们可以看到自动触发函数luaC_condGC包装在了luaC_checkGC函数中\n而lua在每次增删查改lua对象,虚拟栈,引起内存变化的时候,就会自动触发GC流程\n还有一个就是lua虚拟机在执行\nOP_NEWTABLE:新建一个表 OP_CONCAT:拼接对象 OP_CLOSURE:根据函数原型新建一个闭包 这些指令导致内存发送变化时候也会自动触发GC流程\n手动触发 手动触发:luaC_step\nLUA_API int lua_gc (lua_State *L, int what, ...) { ....... case LUA_GCSTEP: { int data = va_arg(argp, int); l_mem debt = 1; /* =1 to signal that it did an actual step */ lu_byte oldstp = g-\u003egcstp; g-\u003egcstp = 0; /* allow GC to run (GCSTPGC must be zero here) */ if (data == 0) { luaE_setdebt(g, 0); /* do a basic step */ luaC_step(L); } else { /* add 'data' to total debt */ debt = cast(l_mem, data) * 1024 + g-\u003eGCdebt; luaE_setdebt(g, debt); luaC_checkGC(L);///这个地方触发 } g-\u003egcstp = oldstp; /* restore previous state */ if (debt \u003e 0 \u0026\u0026 g-\u003egcstate == GCSpause) /* end of cycle? */ res = 1; /* signal it */ break; } ....... } 比如lua层调用collectgarbage(\"step\")语句的时候,就会调用到这里来,等价于手动单步运行垃圾回收\n不管是手动还是自动触发,只要是设置的增量GC方式都会进入singlestep函数\nsinglestep函数就是增量GC的主力函数,因为前面参数的设置调控和singlestep函数内部的逻辑处理,就可以实现增量处理,可以被中断再恢复并继续进行,不会在像双色GC程序必须暂停下来,不能进行其他操作导致卡顿\n开始阶段:GCSpause 从上面可以看出这个阶段主要靠restartcollection函数处理相关逻辑\n进入函数中,我们可以看到这个函数主要是处理了这些事情\n将g-\u003egray灰色节点链 g-\u003egrayagain原子操作灰色节点链表初始化\n将3个和弱表相关的链表初始化\n将mainthread:主执行栈,l_registry:全局注册表,markmt(g):全局元表,markbeingfnz(g):上次GC循环中剩余的finalize中的userdata对象在此进行标记\n而对对象进行标记是由reallymarkobject函数进行的\nreallymarkobject 主要逻辑是直接将 userdata, string, closed upvalue 涂黑, 其它类型对象涂灰等待进一步处理\n当这些都处理完以后就进入了传播阶段:GCSpropagate\n传播阶段:GCSpropagate 从上图中我们可以看到,如果g-\u003egray不等于空,那么就会一直调用propagatemark函数从灰色列表中取出一个灰色对象进行涂黑,并对他的引用进行标记,还有注意这里并不是一个循环一直在循环调用propagatemark函数进行循环取灰色对象,进行标记,而只有g-\u003egray==NULL的时候才会进入下一次GC阶段,由此我们可以看出这个是可以被中断的,毕竟propagatemark函数中有g-\u003egray指针一直记录这执行到了那一个灰色对象,在下次进来的时候从这个地方在开始执行就行了,这样做能有效的减少阻塞时间,更快的响应Lua虚拟机,毕竟谁也不想一直把性能处理长时间丢到这快地方,当gray链表当中的灰色节点处理完以后,就会进入GCSatomic的过渡状态:GCSenteratomic\n从上面其实我们还可以分析出,如果一直在创建对象,创建对象的速度一直大于GCSpropagate的处理速度,那么就会导致一直卡在这里\n解决这个办法,可以有如下方法\n一个是减少gray链表的数量,也就是减少灰色节点的创建,比如少弄一层又一层的引用,举个例子比如你创建了一个table,然后table的value又没有设置week,那么就会变量table中table所有可达的value,如果value是GC对象并且是白色的,那么就会有push到灰色链表当中,这样就子子孙孙无穷尽也,很有可能一直卡在这一块 第二中方法的话可以控制GC的各种阈值变量 比如通过调用collectgarbage(\"setstepmul\")调节gcstepmul阈值变量,让他变小一点,这样就缩小了一步处理GC的工作量,从而减少处理时间 还可以调用collectgarbage(\"setpause\")调节gcpause阈值变量,让他变小点,加快第二次GC开始到来的时间 上面介绍完,我们在来好好的讲解下propagatemark函数里面到底做了啥\n标记table:traversetable 从上图中我们可以分析出主要是通过扫描table类型,key,value的类型,是不是weak方式,决定放入那个全局虚拟机GC链表\nstrong key, weak value\n若 gc 处在 GCSpropagate 阶段, 并且g-\u003egray不为空将 weak table 加入到 g-\u003egrayagain 链表中, 在 atomic phase 再次访问\n否则按下面的规则添加到对应链表\ntable数组部分 若table数组部分中有元素, 并且是atomic phase阶段加入到 g-\u003eweak list\n若table数组部分中没有元素 并且不是atomic phase阶段加入到 g-\u003egrayagain list\ntable hash部分 val is nil: 移除它\nval is not nil: 标记key,若value is白色 (且不为不可回收对象)\n是atomic phase阶段加入到 g-\u003eweak list 不是atomic phase阶段加入到 g-\u003egrayagain list weak key, strong value\ntable数组部分\n遍历数组如果有白色值就进行标记,并marked设置为true\ntable hash部分\n按倒序或者正序遍历进行标记,标记好以后进行如下操作\n若gc 处在GCSpropagate: 把h放入g-\u003egrayagain中\n否则按如下规则处理\n​ val is nil: 移除它\n​ white key-white value: 把h放入g-\u003eephemeron\n​ white key-marked value: 把h放入g-\u003eallweak\n​ marked key-white value: 标记value\n​ 其他:如果是touched1状态把黑色对象link进灰色链表,否则如果是touched2状态改变他的年龄到G_OLD\n3.weak key, weak value\n把table放入g-\u003eallweak\nstrong key, strong value\ntable数组部分\n对value进行标记\ntable hash部分\nvalue is nil: 移除它\nvalue is not nil: 标记key, 标记value\n标记userdata:traverseudata 可以看到主要的事情是对userdata里面的元表和上值进行标记\n标记lua闭包:traverseLclosure 可以看到主要的事情是对lua闭包里面的引用对象函数原型和上值进行标记\n标记C闭包:traverseCclosure 主要是标记C闭包里面所有的上值\n标记函数原型:traverseproto 主要是标记函数原型里面引用的文件名,常量表,上值名,子函数表,局部变量\n标记线程:traversethread 如果现在GC是GCSpropagate阶段,线程也是旧对象,那么就丢到g-\u003egrayagain列表放在后面atomic中进行处理,毕竟thread上关联的对象是Lua运行时的状态,变化很频繁,还不如丢到grayagin表中然后到atomic一次性进行标记处理\n如果现在GC是GCSatomic阶段\n清除已经不在使用的栈空间,并把它们置成nil\n如果线程的上值open链表有值\n标记上值open链表\n如果线程在twups链表中\n若 thread 不在twups链表中,但是 上面有openupval, 则将其重新加入到 g-\u003etwups 链表\n其他类型 就是简单的调用nw2black(o)函数标记成黑色\n屏障操作 luaC_barrier\n向前走一步如果新建对象是白色,而它被一个黑色对象引用了那么将这个新建对象颜色从白色变为灰色\n这么做的主要是因为\n在赋值操作的时候有可能发生黑色对象,指向白色对象的可能性,出现这种情况是不合法的,毕竟如果你一个黑色对象指向了白色对象,比如 lua_load 函数当中的 luaC_barrier(L, f-\u003eupvals[0], gt)执行语句如果不把gt从白色变成灰色,那么在lua GC状态机持续运转中到达回收状态中会把他当白色对象给回收了,那这样就会导致函数的上值表第一个位置存的元素消失,这样肯定是不合理的 也是为了让GC能够感知到你这个黑色对象重新赋值了一个白色对象,如果你不把这个黑色对象新引用的白色对象不改变颜色的话,很有可能在传播阶段和原子阶段因为这个白色对象不在gray链表中无法感知而无法标识这个白色节点引用的东西导致错误 luaC_barrierback\n标记向后一步此时将引用的它的黑色对象的颜色从黑色变为灰色,然后放入grayagain链表当中\n通过观察我们看到这个操作主要是给table使用的\n主要原因是\ntable关联的对象key,value是一对多的关系,如果调用的是向前操作,那么如果加入一个数据,那么就的放入gray链表中去等待扫描,如果引用的层级特别的多,可想而知,这样一直遍历gray链表,等待时间会非常长,增加不必要的开销,还不如向后一步,直接放入grayagain链表在原子阶段直接一次性标记扫描 接下来如果gray链表都标记清除处理完毕了,那么就进入了过渡阶段:GCSenteratomic\n过渡阶段:GCSenteratomic 这个阶段没太多可讲的主要是两个重要函数\natomic:进入原子收集标记阶段 entersweep: sweep过程中把非dead 对象标记为 currentwhite 上面两个函数也留到下一个阶段原子阶段:GCSatomic来讲解\n原子阶段:GCSatomic 从上面的函数这次集中处理的是运行中的协程栈 全局注册表 全局元表 open状态的上值 grayagain链表 弱表链表 所有准备终结的userdata对象 可以看出这次在遍历未处理的数据的时候,是一次性执行的,每一次遍历未处理的数据,都会再次调用propagateall函数以保证这次彻底的把gray链表访问到了\n然后将当前白色值切换到新一轮的白色值(在此之后,所有新建的对象虽然也为白色,但是在GC循环走完之前并不会被回收,而是等待下一轮GC回收)\n原子atomic处理完以后又会调用entersweep函数进入扫描复活模式,主要作用还是为了把这次GC中死亡的对象回收,未死亡的对象设置成当前白\n上述步骤终于做完了,我们就可以进行下一步来到回收阶段了\n清扫阶段 sweepstep函数最终会调用到sweeplist函数,而sweeplist函数上面也介绍过主要是为了把死对象回收,把非死对象标记为当前白\nGCSswpallgc 从上图函数中可以看出g-\u003esweepgc指针执行的是g-\u003eallgc,所以这里的作用主要就是扫描g-\u003eallgc,并把里面的死对象回收,非死亡对象标记为当前白\nGCSswpfinobj GCSswpfinobj同样也调用了sweeplist进行清除并且标记,主要是对global_State.finobj链表的处理,而前面我们也分析过finobj里面存的是什么东西\n从上面可以看出他除了清扫并标记,还做了对自定义__gc元方法调用\nGCSswptobefnz GCSswpfinobj同样也调用了sweeplist进行清除并且标记,,主要是对global_State.tobefnz链表的处理,tobefinz里面存的内容主要userdata对象相关\nGCSswpend GCSswpend最后回收结尾,主要是针对内存的回收,整理,字符串表的收缩,还有存活量的统计\n收尾阶段:GCScallfin 这是最后状态机的最后一步了,主要会对global_State.tobefnz链表进行遍历,然后调用userdata自己定义的__gc元方法,来进行自己的自定义回收,同时还会将tobefnz链表中的对象放到allgc链表中,参与下一次GC回收流程\n分代gc 时间关系,下周补全\nGC通过那些阈值进行调控 时间关系,下周补全\n更详细的注释请去我的GitHub地址 以下是我几乎每行都加了注释的GitHub地址\nlgc.c注释地址\nlgc.c注释\nlgc.h注释地址\nlgc.h注释\n",
  "wordCount" : "9319",
  "inLanguage": "en",
  "image":"https://frog-game.github.io/posts/read/lua5.4.4.gc/image-20230220004042802.png","datePublished": "2023-02-20T01:30:29+08:00",
  "dateModified": "2023-02-20T01:30:29+08:00",
  "author":[{
    "@type": "Person",
    "name": "frog"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://frog-game.github.io/posts/read/lua5.4.4.gc/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "frog's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://frog-game.github.io/img/Q.gif"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>



<script async src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>


<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://frog-game.github.io/" accesskey="h" title="frog&#39;s Blog (Alt + H)">
            <img src="https://frog-game.github.io/img/Q.gif" alt="logo" aria-label="logo"
                 height="35">frog&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://frog-game.github.io/search" title="🔍 搜索 (Alt &#43; /)" accesskey=/>
                <span>🔍 搜索</span>
                </a>
            </li>
            <li>
                <a href="https://frog-game.github.io/" title="🏠 主页">
                <span>🏠 主页</span>
                </a>
            </li>
            <li>
                <a href="https://frog-game.github.io/posts" title="📚 文章">
                <span>📚 文章</span>
                </a>
            </li>
            <li>
                <a href="https://frog-game.github.io/tags" title="🧩 标签">
                <span>🧩 标签</span>
                </a>
            </li>
            <li>
                <a href="https://frog-game.github.io/archives/" title="⏱ 时间轴">
                <span>⏱ 时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://frog-game.github.io/about" title="🙋🏻‍♂️ 关于">
                <span>🙋🏻‍♂️ 关于</span>
                </a>
            </li>
            <li>
                <a href="https://frog-game.github.io/links" title="🤝 友链">
                <span>🤝 友链</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main page">
<article class="post-single">
    <div id="single-content">
        <header class="post-header">
            <div class="breadcrumbs"><a href="https://frog-game.github.io/">主页</a>&nbsp;»&nbsp;<a href="https://frog-game.github.io/posts/">📚文章</a>&nbsp;»&nbsp;<a href="https://frog-game.github.io/posts/read/">📕 阅读</a></div>
            <h1 class="post-title">
                [Lua5.4.4源码].GC
            </h1>
            <div class="post-description">
                lua源码GC分析
            </div>
            <div class="post-meta">创建:&nbsp;<span title='2023-02-20 01:30:29 +0800 CST'>2023-02-20</span>&nbsp;|&nbsp;更新:&nbsp;2023-02-20&nbsp;|&nbsp;字数:&nbsp;9319字&nbsp;|&nbsp;时长:&nbsp;19分钟&nbsp;|&nbsp;
作者:&nbsp;frog



                &nbsp;|&nbsp;标签: &nbsp;
                <ul class="post-tags-meta">
                    <a href="https://frog-game.github.io/tags/lua5.4.4%E6%BA%90%E7%A0%81/">Lua5.4.4源码</a>
                </ul>

                
                <span id="busuanzi_container_page_pv">
                &nbsp;| 访问: <span id="busuanzi_value_page_pv"></span>
            </span>

</div>
        </header> 
<figure class="entry-cover1"><img loading="lazy" src="https://frog-game.github.io/posts/read/lua5.4.4.gc/image-20230220004042802.png" alt="">
        
</figure>
        <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">文章目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#gc%e7%94%b1%e6%9d%a5%e7%ae%80%e4%bb%8b" aria-label="GC由来简介">GC由来简介</a></li>
                <li>
                    <a href="#gc%e6%80%8e%e4%b9%88%e5%9b%9e%e6%94%b6%e5%86%85%e5%ad%98" aria-label="GC怎么回收内存">GC怎么回收内存</a><ul>
                        
                <li>
                    <a href="#%e8%83%bd%e8%a2%abgc%e5%9b%9e%e6%94%b6%e7%9a%84%e5%af%b9%e8%b1%a1" aria-label="能被GC回收的对象">能被GC回收的对象</a></li>
                <li>
                    <a href="#%e9%a2%9c%e8%89%b2%e5%a4%84%e7%90%86" aria-label="颜色处理">颜色处理</a><ul>
                        
                <li>
                    <a href="#%e9%a2%9c%e8%89%b2bit%e4%bd%8d%e7%b4%a2%e5%bc%95" aria-label="颜色bit位索引">颜色bit位索引</a></li>
                <li>
                    <a href="#%e9%a2%9c%e8%89%b2bit%e4%bd%8d%e6%a3%80%e6%b5%8b" aria-label="颜色bit位检测">颜色bit位检测</a><ul>
                        
                <li>
                    <a href="#iswhitex-%e6%98%af%e4%b8%8d%e6%98%af%e7%99%bd%e8%89%b2" aria-label="iswhite(x) 是不是白色">iswhite(x) 是不是白色</a></li>
                <li>
                    <a href="#isblackx-%e6%98%af%e4%b8%8d%e6%98%af%e9%bb%91%e8%89%b2" aria-label="isblack(x) 是不是黑色">isblack(x) 是不是黑色</a></li>
                <li>
                    <a href="#isgrayx-%e6%98%af%e4%b8%8d%e6%98%af%e7%81%b0%e8%89%b2" aria-label="isgray(x) 是不是灰色">isgray(x) 是不是灰色</a></li>
                <li>
                    <a href="#tofinalizex%e6%98%af%e4%b8%8d%e6%98%af%e6%a0%87%e8%af%86%e4%ba%86userdata" aria-label="tofinalize(x)是不是标识了userdata">tofinalize(x)是不是标识了userdata</a></li>
                <li>
                    <a href="#%e9%bb%91%e8%89%b2%e7%99%bd%e8%89%b2%e4%bd%8d%e6%8e%a7%e5%88%b6" aria-label="黑色,白色位控制">黑色,白色位控制</a><ul>
                        
                <li>
                    <a href="#otherwhiteg-%e9%9d%9e%e5%bd%93%e5%89%8d%e7%99%bd" aria-label="otherwhite(g) 非当前白">otherwhite(g) 非当前白</a></li>
                <li>
                    <a href="#luac_whiteg-%e5%bd%93%e5%89%8d%e7%99%bd" aria-label="luaC_white(g) 当前白">luaC_white(g) 当前白</a></li>
                <li>
                    <a href="#changewhitex-%e6%94%b9%e5%8f%98%e5%bd%93%e5%89%8d%e7%99%bd%e8%89%b2%e4%bd%8d" aria-label="changewhite(x) 改变当前白色位">changewhite(x) 改变当前白色位</a></li>
                <li>
                    <a href="#nw2blackx-%e8%ae%be%e7%bd%ae%e6%88%90%e9%bb%91%e8%89%b2" aria-label="nw2black(x) 设置成黑色">nw2black(x) 设置成黑色</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e9%a2%9c%e8%89%b2%e6%98%af%e5%90%a6%e5%8f%af%e8%a2%ab%e5%9b%9e%e6%94%b6" aria-label="颜色是否可被回收">颜色是否可被回收</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%b9%b4%e9%be%84%e5%a4%84%e7%90%86" aria-label="年龄处理">年龄处理</a><ul>
                        
                <li>
                    <a href="#%e5%b9%b4%e9%be%84bit%e4%bd%8d%e7%b4%a2%e5%bc%95" aria-label="年龄bit位索引">年龄bit位索引</a></li>
                <li>
                    <a href="#getageo-%e8%8e%b7%e5%8f%96%e5%b9%b4%e9%be%84" aria-label="getage(o) 获取年龄">getage(o) 获取年龄</a></li>
                <li>
                    <a href="#setageoa-%e8%ae%be%e7%bd%ae%e5%b9%b4%e9%be%84" aria-label="setage(o,a) 设置年龄">setage(o,a) 设置年龄</a></li>
                <li>
                    <a href="#changeageoft-%e6%94%b9%e5%8f%98%e5%b9%b4%e9%be%84" aria-label="changeage(o,f,t) 改变年龄">changeage(o,f,t) 改变年龄</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%a2%9e%e9%87%8fgc" aria-label="增量GC">增量GC</a><ul>
                        
                <li>
                    <a href="#%e5%a2%9e%e9%87%8fgc%e6%97%b6%e5%80%99%e5%ad%98%e6%94%begcobject%e7%9a%84%e9%93%be%e8%a1%a8" aria-label="增量GC时候存放GCobject的链表">增量GC时候存放GCobject的链表</a></li>
                <li>
                    <a href="#%e5%a2%9e%e9%87%8fgc%e6%b5%81%e7%a8%8b" aria-label="增量GC流程">增量GC流程</a><ul>
                        
                <li>
                    <a href="#%e6%96%b0%e5%bb%ba%e5%af%b9%e8%b1%a1%e9%98%b6%e6%ae%b5" aria-label="新建对象阶段">新建对象阶段</a></li>
                <li>
                    <a href="#gc%e8%a7%a6%e5%8f%91%e9%98%b6%e6%ae%b5" aria-label="GC触发阶段">GC触发阶段</a><ul>
                        
                <li>
                    <a href="#%e8%87%aa%e5%8a%a8%e8%a7%a6%e5%8f%91" aria-label="自动触发">自动触发</a></li>
                <li>
                    <a href="#%e6%89%8b%e5%8a%a8%e8%a7%a6%e5%8f%91" aria-label="手动触发">手动触发</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%bc%80%e5%a7%8b%e9%98%b6%e6%ae%b5gcspause" aria-label="开始阶段:GCSpause">开始阶段:GCSpause</a></li>
                <li>
                    <a href="#%e4%bc%a0%e6%92%ad%e9%98%b6%e6%ae%b5gcspropagate" aria-label="传播阶段:GCSpropagate">传播阶段:GCSpropagate</a><ul>
                        
                <li>
                    <a href="#%e6%a0%87%e8%ae%b0tabletraversetable" aria-label="标记table:traversetable">标记table:traversetable</a></li>
                <li>
                    <a href="#%e6%a0%87%e8%ae%b0userdatatraverseudata" aria-label="标记userdata:traverseudata">标记userdata:traverseudata</a></li>
                <li>
                    <a href="#%e6%a0%87%e8%ae%b0lua%e9%97%ad%e5%8c%85traverselclosure" aria-label="标记lua闭包:traverseLclosure">标记lua闭包:traverseLclosure</a></li>
                <li>
                    <a href="#%e6%a0%87%e8%ae%b0c%e9%97%ad%e5%8c%85traversecclosure" aria-label="标记C闭包:traverseCclosure">标记C闭包:traverseCclosure</a></li>
                <li>
                    <a href="#%e6%a0%87%e8%ae%b0%e5%87%bd%e6%95%b0%e5%8e%9f%e5%9e%8btraverseproto" aria-label="标记函数原型:traverseproto">标记函数原型:traverseproto</a></li>
                <li>
                    <a href="#%e6%a0%87%e8%ae%b0%e7%ba%bf%e7%a8%8btraversethread" aria-label="标记线程:traversethread">标记线程:traversethread</a></li>
                <li>
                    <a href="#%e5%85%b6%e4%bb%96%e7%b1%bb%e5%9e%8b" aria-label="其他类型">其他类型</a></li>
                <li>
                    <a href="#%e5%b1%8f%e9%9a%9c%e6%93%8d%e4%bd%9c" aria-label="屏障操作">屏障操作</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%bf%87%e6%b8%a1%e9%98%b6%e6%ae%b5gcsenteratomic" aria-label="过渡阶段:GCSenteratomic">过渡阶段:GCSenteratomic</a></li>
                <li>
                    <a href="#%e5%8e%9f%e5%ad%90%e9%98%b6%e6%ae%b5gcsatomic" aria-label="原子阶段:GCSatomic">原子阶段:GCSatomic</a></li>
                <li>
                    <a href="#%e6%b8%85%e6%89%ab%e9%98%b6%e6%ae%b5" aria-label="清扫阶段">清扫阶段</a><ul>
                        
                <li>
                    <a href="#gcsswpallgc" aria-label="GCSswpallgc">GCSswpallgc</a></li>
                <li>
                    <a href="#gcsswpfinobj" aria-label="GCSswpfinobj">GCSswpfinobj</a></li>
                <li>
                    <a href="#gcsswptobefnz" aria-label="GCSswptobefnz">GCSswptobefnz</a></li>
                <li>
                    <a href="#gcsswpend" aria-label="GCSswpend">GCSswpend</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%94%b6%e5%b0%be%e9%98%b6%e6%ae%b5gcscallfin" aria-label="收尾阶段:GCScallfin">收尾阶段:GCScallfin</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%88%86%e4%bb%a3gc" aria-label="分代gc">分代gc</a></li>
                <li>
                    <a href="#gc%e9%80%9a%e8%bf%87%e9%82%a3%e4%ba%9b%e9%98%88%e5%80%bc%e8%bf%9b%e8%a1%8c%e8%b0%83%e6%8e%a7" aria-label="GC通过那些阈值进行调控">GC通过那些阈值进行调控</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e6%9b%b4%e8%af%a6%e7%bb%86%e7%9a%84%e6%b3%a8%e9%87%8a%e8%af%b7%e5%8e%bb%e6%88%91%e7%9a%84github%e5%9c%b0%e5%9d%80" aria-label="更详细的注释请去我的GitHub地址">更详细的注释请去我的GitHub地址</a>
                </li>
            </ul>
        </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        
        activeElement = elements[0];
        const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
        document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
    }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 &&
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
            const id = encodeURI(element.getAttribute('id')).toLowerCase();
            if (element === activeElement){
                document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
            } else {
                document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
            }
        })
    }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;
    }
</script>
        
        <div class="post-content"><h2 id="gc由来简介"><span>GC由来简介</span></h2>
<p><code>c,c++</code>的话基本都是手动管理内存,优点是效率很高,毕竟不需要去找出那些是垃圾,需要被清理这种逻辑处理,也不需要在<code>gc</code>清理的时候,把主线程暂停,等等操作造成卡顿,但是这种手动管理的也有一定的问题,那就是内存碎片,还有内存重复复用,所以会利用内存池管理这种技术来尽量规避这种情况</p>
<p>比如不使用内存池分配技术,只使用<code>Malloc,free</code>申请空间就很容易造成如下图的内存碎片</p>
<p>内碎片</p>
<ul>
<li>
<p>内碎片是已经被分配出去的内存[<code>进程已经拿到手上了</code>],但是进程已经利用不上了</p>
</li>
<li>
<p>如下图,当时进程我需要申请了<code>14KB</code>的内存,然后因为<code>linux伙伴算法</code>导致返回了<code>16KB</code>内存,因为<code>伙伴算法</code>是按接近最大的<code>2的幂</code>返回内存空间,导致了<code>2KB</code>的冗余,因为这<code>2KB</code>非常小,很有可能内部进程使用不到,如果一直这样请求,就会导致了很多细小的不连续的内部休闲空间[<code>碎片</code>],当内部进程需要分配一大片连续的内存的时候,即使有很多细小的空间组合起来能大于需要申请的空间,但是因为不连续也就无能为力,不能满足要求,这样就造成了内碎片</p>
<p><img loading="lazy" src="image-20230217162532088.png" alt="image-20230217162532088"  />
</p>
</li>
</ul>
<p>外碎片</p>
<ul>
<li>
<p>外部碎片指的是还没有被分配出去[<code>进程还没有拿到手</code>],但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。</p>
</li>
<li>
<p>主要原因还是频繁的申请释放导致了外碎片的存在</p>
<p>如下图我开始申请了<code>16KB</code>的资源,然后又申请了<code>16KB</code>的,这个时候把我第一块的<code>16KB</code>给<code>free</code>掉,他就不属于任何进程,然后进程又来了许多个请求,一直需要<code>18KB</code>的内存,因为第一块只有<code>16KB</code>,而且因为伙伴算法的释放规则是相邻的地址才能进行合并释放,但是第2块内存一直被进程占着,所以第一块和第二块也合并不了,一直利用不上,导致了外碎片的存在</p>
<p><img loading="lazy" src="image-20230217164910076.png" alt="image-20230217164910076"  />
</p>
</li>
</ul>
<p>为了解决外碎片<code>linux</code>使用了伙伴算法</p>
<p>为了解决内碎片<code>linux</code>使用了<code>slab</code>算法,其实<code>slab</code>算法内部实现就是一个内存池逻辑结构</p>
<p>利用上面的办法虽然对内存的管控已经几乎完美,但是因为还是程序员直接内存裸操纵,还是难以避免开发的时候,造成内存的崩溃,野指针,内存泄露,溢出,各种异常问题,于是为了解决这些问题,同时提升开发效率,不用程序员太关心内存处理,于是就有了现在的<code>GC</code>机制[<code>智能指针是另外一回事</code>]</p>
<ul>
<li>
<p>现在有了<code>GC机制</code>,但是内部没有合理的回收机制释放管理这些内存空间,比如如果因为申请和释放规则的不合理,一直申请内存,缓慢释放内存,就有可能造成像人一样吃的太饱,撑的不行,导致人思维缓慢(<code>垃圾不需要内存过多,机器查找需要的内存查找不过来</code>),甚至撑死(<code>再也没有内存申请挂了</code> <code>撑死的时候不一定会产生coredump文件</code>)</p>
<p><strong>题外话为什么不一定产生<code>coredump</code>文件</strong></p>
<pre><code> &gt;`dump`文件只有在程序崩溃时才会生成,如果程序没有奔溃,那么可能是如下情况导致
 &gt;
 &gt;主要是因为`linux`有一个叫做`OOM-killer(Out Of Memory killer)`的机制,`OOM killer`会   在系统内存耗尽的情况下触发,选择性的干掉一些进程,以求释放一些内存
 &gt;
 &gt;当发生这种崩了,但是没有产生`coredump`的情况,可以去系统日志文件`/var/log/messages`看看里面   有没有相关日志记录,你是因为被`OOM-killer`机制给杀掉了进程
</code></pre>
</li>
</ul>
<p>总之一句话来说:<code>GC</code>主要解决的就是内存过多,怎么<strong>合理回收垃圾内存的这些事儿</strong></p>
<h2 id="gc怎么回收内存"><span>GC怎么回收内存</span></h2>
<p><code>LuaGC</code>,<code>java gc</code>等等其他语言<code>GC</code>发展历史就不详细描述了,主要还是讲讲<code>Lua5.4GC</code>回收原理</p>
<p>主要有两种一种是<code>分代GC</code>,一种是<code>增量GC</code></p>
<p><img loading="lazy" src="image-20230217174930604.png" alt="image-20230217174930604"  />
</p>
<h3 id="能被gc回收的对象"><span>能被GC回收的对象</span></h3>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#cdcd00">union</span> GCUnion {
</span></span><span style="display:flex;"><span>  GCObject gc;  <span style="color:#000080">/* common header */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#cdcd00">struct</span> TString ts;<span style="color:#000080">//字符串
</span></span></span><span style="display:flex;"><span><span style="color:#000080"></span>  <span style="color:#cdcd00">struct</span> Udata u;<span style="color:#000080">//用户数据
</span></span></span><span style="display:flex;"><span><span style="color:#000080"></span>  <span style="color:#cdcd00">union</span> Closure cl;<span style="color:#000080">//闭包
</span></span></span><span style="display:flex;"><span><span style="color:#000080"></span>  <span style="color:#cdcd00">struct</span> Table h;<span style="color:#000080">//表
</span></span></span><span style="display:flex;"><span><span style="color:#000080"></span>  <span style="color:#cdcd00">struct</span> Proto p;<span style="color:#000080">//函数原型:存放函数字节码信息
</span></span></span><span style="display:flex;"><span><span style="color:#000080"></span>  <span style="color:#cdcd00">struct</span> lua_State th;  <span style="color:#000080">/* thread */</span><span style="color:#000080">//线程
</span></span></span><span style="display:flex;"><span><span style="color:#000080"></span>  <span style="color:#cdcd00">struct</span> UpVal upv;<span style="color:#000080">//上值
</span></span></span><span style="display:flex;"><span><span style="color:#000080"></span>};
</span></span></code></pre></div><p><img loading="lazy" src="image-20230219193823656.png" alt="image-20230219193823656"  />
</p>
<p>关于回收对象更详细的一些内容在这里就不详细的叙述了,想要了解的可以去我的博客下面地址了解</p>
<p><a href="https://frog-game.github.io/posts/read/lua5.4.4.type/#gc%E5%AF%B9%E8%B1%A1"><strong>GC对象</strong></a></p>
<h3 id="颜色处理"><span>颜色处理</span></h3>
<p><img loading="lazy" src="image-20230218115315214.png" alt="image-20230218115315214"  />
</p>
<p>从上图中我们可以看出<code>lua</code>为了效率和内存着想用的是一个字节<code>8</code>个<code>bit</code>位之间的相互作用来标识颜色,和分代<code>GC</code>的年龄情况</p>
<h4 id="颜色bit位索引"><span>颜色bit位索引</span></h4>
<table>
<thead>
<tr>
<th>颜色</th>
<th>简介</th>
<th>宏运算</th>
<th>二进制</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr>
<td>WHITE0BIT  3</td>
<td>白0</td>
<td>bitmask(3)</td>
<td>1000</td>
<td>bit第3位设置成1</td>
</tr>
<tr>
<td>WHITE1BIT 4</td>
<td>白1</td>
<td>bitmask(4)</td>
<td>10000</td>
<td>bit第4位设置成1</td>
</tr>
<tr>
<td>BLACKBIT 5</td>
<td>黑色</td>
<td>bitmask(5)</td>
<td>100000</td>
<td>bit第5位设置成1</td>
</tr>
<tr>
<td>FINALIZEDBIT 6</td>
<td>用于标记userdata</td>
<td>bitmask(6)</td>
<td>1000000</td>
<td>bit第6位设置成1</td>
</tr>
<tr>
<td>WHITEBITS</td>
<td>白色</td>
<td>bit2mask(WHITE0BIT, WHITE1BIT)</td>
<td>11000</td>
<td>bit第3,4位设置成1</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>为啥<code>lua5.4</code>要把白色分成两个标识呢,主要是因为如果对象在<code>GC</code>标记阶段之后创建对象,这个时候假如只有一个白色标识位,那么新创建的对象就会设置成白色,设置成功以后接下来到了回收阶段,因为白色是表示可回收的,那么新创建的对象会被认为没有引用而被删除了,这个逻辑肯定是不对的,不合理是的</p>
</li>
<li>
<p>所以为了解决这种不合理情况<code>lua</code>创造了<code>白0</code> <code>白1</code>两种状态来进行乒乓切换,其实也就是当前白和非当前白状态的乒乓切换</p>
</li>
<li>
<p>特别注意并没有固定设置<code>白0</code>就是<code>当前白</code>,<code>白1</code>就是<code>非当前白</code>,是不是当前白是由当前<code>GC</code>使用的白色是啥决定</p>
</li>
<li>
<p>当<code>GC</code>来到了回收阶段的时候,如果发现对象标识的颜色不是<code>当前白</code>,那么就会认为是没有引用而直接回收,而刚标识阶段和回收阶段之间创建的对象是<code>当前白</code>,就不会参与这次``GC<code>回收,而到下一次</code>GC<code>回收才回收掉,毕竟因为乒乓切换,当前白到下一次</code>GC`也会变成其它白状态</p>
</li>
</ul>
<h4 id="颜色bit位检测"><span>颜色bit位检测</span></h4>
<h5 id="iswhitex-是不是白色"><span>iswhite(x) 是不是白色</span></h5>
<p><img loading="lazy" src="image-20230218152932979.png" alt="image-20230218152932979"  />
</p>
<p>如果<code>bit</code>位第 <code>3,4</code>位中任意一位是<code>1</code>那么就认为他是白色标识</p>
<h5 id="isblackx-是不是黑色"><span>isblack(x) 是不是黑色</span></h5>
<p><img loading="lazy" src="image-20230218153532888.png" alt="image-20230218153532888"  />
</p>
<p>如果<code>bit</code>位第<code>5</code>位是<code>1</code>,那么就认为是黑色标识</p>
<h5 id="isgrayx-是不是灰色"><span>isgray(x) 是不是灰色</span></h5>
<p><img loading="lazy" src="image-20230218154702514.png" alt="image-20230218154702514"  />
</p>
<p>如果<code>bit</code>位第<code>3,4,,5</code>位都是<code>0</code>,那么就认为是灰色标识</p>
<h5 id="tofinalizex是不是标识了userdata"><span>tofinalize(x)是不是标识了userdata</span></h5>
<p><img loading="lazy" src="image-20230218155151783.png" alt="image-20230218155151783"  />
</p>
<p>如果<code>bit</code>位第<code>6</code>位是<code>1</code>,那么就认为标识了<code>userdata</code>,注意并没有红色颜色这个标识,只是我为了区分其他颜色涂上的</p>
<p>主要还是<code>userdata</code>类型不同于其他类型,用户可以自己传入数据,设置<code>gc</code>元方法,自定义释放内存,所以 当 <code>userdata</code> 确认不被引用,则设置上这个标记,后面统一管理释放资源</p>
<h5 id="黑色白色位控制"><span>黑色,白色位控制</span></h5>
<p>注意到白色位是乒乓效应的,也就是<code>3,4</code>号位是互斥状态</p>
<h6 id="otherwhiteg-非当前白"><span>otherwhite(g) 非当前白</span></h6>
<p><img loading="lazy" src="image-20230218161224357.png" alt="image-20230218161224357"  />
</p>
<p>宏公式<code>((g)-&gt;currentwhite ^ WHITEBITS)</code></p>
<p>表示非当前<code>GC</code>将要回收的白色类型  比如</p>
<ul>
<li>
<p>如果<code>(g)-&gt;currentwhite</code>是<code>1000</code> <code>1000 ^ 11000 = 10000</code></p>
</li>
<li>
<p>如果<code>(g)-&gt;currentwhite</code>的值是<code>10000</code>的话, <code>10000 ^ 11000 = 1000</code></p>
</li>
</ul>
<p>结果正好相反</p>
<h6 id="luac_whiteg-当前白"><span>luaC_white(g) 当前白</span></h6>
<p><img loading="lazy" src="image-20230218161224357.png" alt="image-20230218161224357"  />
</p>
<p>宏公式<code>cast_byte((g)-&gt;currentwhite &amp; WHITEBITS)</code></p>
<p>表示得到当前的要回收的白色类型 比如</p>
<ul>
<li>
<p>如果<code>(g)-&gt;currentwhite</code>是<code>1000</code> <code>1000 &amp; 11000 = 01000</code>, <code>1000 &amp; 11000</code>还是<code>1000</code></p>
</li>
<li>
<p>如果<code>(g)-&gt;currentwhite</code>是<code>10000</code>  <code>10000 &amp; 11000 = 10000</code>, <code>10000 &amp;11000</code>还是<code>10000</code></p>
</li>
</ul>
<h6 id="changewhitex-改变当前白色位"><span>changewhite(x) 改变当前白色位</span></h6>
<p>宏公式<code>((x)-&gt;marked ^= WHITEBITS) </code></p>
<ol>
<li>
<p>比如如果现在<code>((x)-&gt;marked</code>是<code>101000</code></p>
<p><img loading="lazy" src="image-20230218165848927.png" alt="image-20230218165848927"  />
</p>
<p>这个时候执行了一下<code>changewhite(x)</code>  <code>101000 ^ 11000 = 110000</code> 因为是异或逻辑</p>
<ul>
<li>
<p><code>0和任何数异或是本身</code></p>
</li>
<li>
<p><code>1和任何数异或是他相反的bit位</code></p>
</li>
</ul>
<p>所以我们得到了如下图结果</p>
<p><img loading="lazy" src="image-20230218165856873.png" alt="image-20230218165856873"  />
</p>
</li>
<li>
<p>比如如果现在<code>((x)-&gt;marked</code>是<code>110000</code></p>
<p><img loading="lazy" src="image-20230218170119416.png" alt="image-20230218170119416"  />
</p>
<p>这个时候执行了一下<code>changewhite(x)</code>  <code>110000 ^ 11000 = 101000</code> 因为是异或逻辑</p>
<ul>
<li>
<p><code>0和任何数异或是本身</code></p>
</li>
<li>
<p><code>1和任何数异或是他相反的bit位</code></p>
</li>
</ul>
<p>所以我们得到了如下图结果</p>
<p><img loading="lazy" src="image-20230218170127448.png" alt="image-20230218170127448"  />
</p>
</li>
</ol>
<h6 id="nw2blackx-设置成黑色"><span>nw2black(x) 设置成黑色</span></h6>
<p><img loading="lazy" src="image-20230218171618440.png" alt="image-20230218171618440"  />
</p>
<p>当<code>bit</code> <code>3,4</code>位都是<code>0</code>然后就可以设成把<code>5</code>号位设置成黑色了</p>
<h4 id="颜色是否可被回收"><span>颜色是否可被回收</span></h4>
<table>
<thead>
<tr>
<th>颜色</th>
<th>状态</th>
<th>当前GC回收阶段是否回收</th>
</tr>
</thead>
<tbody>
<tr>
<td>当前白</td>
<td>下次GC回收状态</td>
<td>不回收</td>
</tr>
<tr>
<td>其他白</td>
<td>回收状态</td>
<td>回收</td>
</tr>
<tr>
<td>灰色</td>
<td>当前对象为待标记状态</td>
<td>不回收</td>
</tr>
<tr>
<td>黑色</td>
<td>当前对象为已标记状态</td>
<td>不回收</td>
</tr>
</tbody>
</table>
<h3 id="年龄处理"><span>年龄处理</span></h3>
<h4 id="年龄bit位索引"><span>年龄bit位索引</span></h4>
<p><code>age</code>使用的位<code>mask</code>,<code>age</code>只使用了<code>marked</code>的<code>0,1,2</code>位置</p>
<p><img loading="lazy" src="image-20230218233208710.png" alt="image-20230218233208710"  />
</p>
<p>青年对象</p>
<table>
<thead>
<tr>
<th style="text-align:left">宏定义</th>
<th>二进制</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">G_NEW 0</td>
<td>000</td>
<td>本次cycle创建的新对象(没有引用任何old对象)</td>
</tr>
<tr>
<td style="text-align:left">G_SURVIVAL 1</td>
<td>001</td>
<td>当前gc存活下来的对象</td>
</tr>
<tr>
<td style="text-align:left">G_OLD0 2</td>
<td>010</td>
<td>当前gc循环被barrier forward的节点,如果被插入的节点为isold()为true的节点</td>
</tr>
</tbody>
</table>
<p>老年对象</p>
<table>
<thead>
<tr>
<th>宏定义</th>
<th>二进制</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr>
<td>G_OLD1 3</td>
<td>011</td>
<td>活过了一次完整的gc</td>
</tr>
<tr>
<td>G_OLD 4</td>
<td>100</td>
<td>活过了两次完整的gc,标记为G_OLD,不再被访问</td>
</tr>
<tr>
<td>G_TOUCHED1 5</td>
<td>101</td>
<td>old节点被插入新节点</td>
</tr>
<tr>
<td>G_TOUCHED2 6</td>
<td>110</td>
<td>G_TOUCHED1节点经过一次完整的gc还没有新的节点插入</td>
</tr>
</tbody>
</table>
<h4 id="getageo-获取年龄"><span>getage(o) 获取年龄</span></h4>
<p>宏公式<code>((o)-&gt;marked &amp; AGEBITS)</code></p>
<p>主要是利用了和<code>#define AGEBITS 7 </code>也就是二进制<code>111</code>的与运算得到当前的年龄毕竟与运算逻辑是</p>
<ul>
<li><code>1 &amp; 1 = 1</code></li>
<li><code>0 &amp; 1 = 0</code></li>
</ul>
<p>等价于留下了低<code>3</code>位的数据</p>
<h4 id="setageoa-设置年龄"><span>setage(o,a) 设置年龄</span></h4>
<p>宏公式<code>((o)-&gt;marked = cast_byte(((o)-&gt;marked &amp; (~AGEBITS)) | a))</code></p>
<p><code>~AGEBITS</code> 等价于低<code>3</code>位是<code>000</code> 其他位都是<code>1</code> 比如<code>64</code>位系统得到结果是这样</p>
<p><code>1111111111111111111111111111111111111111111111111111111111111000</code></p>
<p><code>(o)-&gt;marked &amp; (~AGEBITS))</code> 进行与运算以后等价于高<code>3</code>位以上都会留下来毕竟与运算逻辑是</p>
<ul>
<li><code>1 &amp; 1 = 1</code></li>
<li><code>0 &amp; 1 = 0</code></li>
</ul>
<p><code>(o)-&gt;marked &amp; (~AGEBITS)) | a</code></p>
<p>然后和<code>a</code>进行或运算,这个就等价于进行或运算的组合逻辑了 毕竟或运算逻辑</p>
<ul>
<li>
<p><code>0 | 0 = 0</code></p>
</li>
<li>
<p><code>0 | 1 = 1</code></p>
</li>
<li>
<p><code>1 | 0 = 1</code></p>
</li>
<li>
<p><code>1 | 1 = 1</code></p>
</li>
</ul>
<h4 id="changeageoft-改变年龄"><span>changeage(o,f,t) 改变年龄</span></h4>
<p>宏公式<code>check_exp(getage(o) == (f), (o)-&gt;marked ^= ((f)^(t)))</code></p>
<ul>
<li>
<p>从<code>f</code>变到<code>t</code> 前提是<code>o</code>的年龄要等于<code>f </code>举个例子<code>changeage(curr, G_TOUCHED1, G_TOUCHED2)</code> 如果<code>getage(o) == (f) </code>那么<code>marked</code>的低<code>3</code>位是<code>101 101^=(101^110)</code> ,<code>101^=011 o-&gt;marked=110</code>  也就等价与<code>o-&gt;marked</code>从<code>101</code>变到了<code>110</code></p>
</li>
<li>
<p>这个公式是<code>lua</code>作者利用对同一个值进行两次异或等于本身原理来达到这样的效果</p>
<ul>
<li>
<p><code>0 ⊕ x = x</code></p>
</li>
<li>
<p><code>1 ⊕ x = x'</code>(<code>x'</code>表示取反)</p>
</li>
<li>
<p><code>x ⊕ x = 0</code></p>
</li>
<li>
<p>所以有 <code>y ⊕ x ⊕ x = y</code></p>
</li>
</ul>
</li>
</ul>
<h3 id="增量gc"><span>增量GC</span></h3>
<p>经过前面的叙述,我们能知道<code>Lua</code> <code>增量GC</code>使用的是<code>4</code>色标记清除算法</p>
<ul>
<li><code>当前白</code>:表示本轮<code>GC</code>不会被回收的对象,也是对象开始创建时候的初始状态</li>
<li><code>其他白</code>:表示本轮<code>GC</code>要被回收的对象,这个白一般都是上轮<code>GC</code>留下来的旧白,也可以认为这个白已经没有引用任何对象了</li>
<li><code>灰色</code>:表示本来<code>GC</code>对象引用的其他对象还没有被访问到,需要进行扫描标记</li>
<li><code>黑色</code>:表示本来<code>GC</code>对象引用的其他对象都已经被访问过了</li>
</ul>
<h4 id="增量gc时候存放gcobject的链表"><span>增量GC时候存放GCobject的链表</span></h4>
<p><code>lua</code>本身有一个<code>global_State</code>的全局状态机,这里存着需要被<code>GC</code>流程处理的数据,大概如下所示</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#cdcd00">typedef</span> <span style="color:#cdcd00">struct</span> global_State {
</span></span><span style="display:flex;"><span>	GCObject <span style="color:#39c">*</span>allgc;
</span></span><span style="display:flex;"><span>  	GCObject <span style="color:#39c">**</span>sweepgc;
</span></span><span style="display:flex;"><span>   	GCObject <span style="color:#39c">*</span>finobj;
</span></span><span style="display:flex;"><span>  	GCObject <span style="color:#39c">*</span>gray; 
</span></span><span style="display:flex;"><span>  	GCObject <span style="color:#39c">*</span>grayagain; 
</span></span><span style="display:flex;"><span>  	GCObject <span style="color:#39c">*</span>weak; 
</span></span><span style="display:flex;"><span>  	GCObject <span style="color:#39c">*</span>ephemeron; 
</span></span><span style="display:flex;"><span>  	GCObject <span style="color:#39c">*</span>allweak; 
</span></span><span style="display:flex;"><span>  	GCObject <span style="color:#39c">*</span>tobefnz; 
</span></span><span style="display:flex;"><span>  	GCObject <span style="color:#39c">*</span>fixedgc; 
</span></span><span style="display:flex;"><span>    <span style="color:#cdcd00">struct</span> lua_State <span style="color:#39c">*</span>twups; 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><table>
<thead>
<tr>
<th>链表</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>allgc</td>
<td>存放待<code>GC</code>对象的链表,所有对象创建之后都会放入该链表中</td>
</tr>
<tr>
<td>sweepgc</td>
<td>由于回收阶段不是一次性全部回收这个链表的所有数据<br />所以使用这个变量来保存当前回收的位置,下一次从这个位置开始继续回收操作</td>
</tr>
<tr>
<td>finobj</td>
<td>存放所有带有析构函数<code>(__gc)</code>的<code>GC obj</code>链表</td>
</tr>
<tr>
<td>gray</td>
<td>存放灰色节点的链表</td>
</tr>
<tr>
<td>grayagain</td>
<td>存放需要一次性扫描处理的灰色节点链表,也就是说,这个链表上所有数据的处理需要一步到位<br />不能被打断</td>
</tr>
<tr>
<td>weak</td>
<td>存放弱值的链表</td>
</tr>
<tr>
<td>ephemeron</td>
<td>键值对<code>(pair)</code>,键是弱引用,但键对值的 <code>mark</code> 有如下影响<br />如果键可达<code>(reachable)</code>,则 <code>mark</code> 其值<br />如果键不可达,则不必<code> mark</code> 其值<br />主要用来解决弱表的循环引用问题  <br />弱引用<code>(weak reference)</code>:可以访问对象,但不会阻止对象被收集<br />弱表<code>(weak table)</code>:键或(和)值是弱引用</td>
</tr>
<tr>
<td>allweak</td>
<td>具有要清除的弱键或弱值 或者弱键弱值同时存在的表</td>
</tr>
<tr>
<td>tobefnz</td>
<td>所有准备终结的<code>userdata</code>对象</td>
</tr>
<tr>
<td>fixedgc</td>
<td>永远不回收的对象链表, 如保留关键字的字符串, 对象必须在创建之后马上<br />从 <code>allgc</code> 链表移入该链表中, 用的是 <code>lgc.c </code>中的 <code>luaC_fix</code> 函数</td>
</tr>
<tr>
<td>twups</td>
<td>所有带有<code>open upvalue</code> 的 <code>thread</code> 都会放到这个链表中<br />这样提供了一个方便的遍历 <code>thread </code>的途径<br />并且排除掉了没有 <code>open upvalue</code> 的 <code>thread</code></td>
</tr>
</tbody>
</table>
<h4 id="增量gc流程"><span>增量GC流程</span></h4>
<p><img loading="lazy" src="image-20230220004042802.png" alt="image-20230220004042802"  />
</p>
<p>上图是增量<code>GC</code>的简易流程图,每个步骤关键的函数,我也画在了上面,大家先初步了解,能有一个大概印象,接下来我将详细的讲解里面的弯弯绕绕,细节部分</p>
<h5 id="新建对象阶段"><span>新建对象阶段</span></h5>
<p><img loading="lazy" src="image-20230219194446841.png" alt="image-20230219194446841"  />
</p>
<p>从上图我们可以看到</p>
<ul>
<li>在创建一个新的<code>GC</code>类型的对象的时候,它都会把当前<code>GC</code>的颜色标识设置成当前白</li>
<li>并且还会把用头插法的方法,将新创建的对象 放入全局状态机的<code>allgc</code>链表当中,这其实也透露出因为用了头插法,所以我们在<code>GC</code>扫描的时候能优先扫描新创建的对象,需要接下来被GC待扫描处理的对象都会存在这个里面</li>
</ul>
<h5 id="gc触发阶段"><span>GC触发阶段</span></h5>
<h6 id="自动触发"><span>自动触发</span></h6>
<p><code>自动触发:luaC_checkGC,checkGC</code></p>
<p><img loading="lazy" src="image-20230219202358698.png" alt="image-20230219202358698"  />
</p>
<p>我们可以看到自动触发函数<code>luaC_condGC</code>包装在了<code>luaC_checkGC</code>函数中</p>
<p>而<code>lua</code>在每次增删查改<code>lua</code>对象,虚拟栈,引起内存变化的时候,就会自动触发<code>GC</code>流程</p>
<p><img loading="lazy" src="image-20230219202544718.png" alt="image-20230219202544718"  />
</p>
<p>还有一个就是<code>lua</code>虚拟机在执行</p>
<ul>
<li><code>OP_NEWTABLE</code>:新建一个表</li>
<li><code>OP_CONCAT</code>:拼接对象</li>
<li><code>OP_CLOSURE</code>:根据函数原型新建一个闭包</li>
</ul>
<p>这些指令导致内存发送变化时候也会自动触发<code>GC</code>流程</p>
<h6 id="手动触发"><span>手动触发</span></h6>
<p><code>手动触发:luaC_step</code></p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>LUA_API <span style="color:#00cd00">int</span> lua_gc (lua_State <span style="color:#39c">*</span>L, <span style="color:#00cd00">int</span> what, ...) {
</span></span><span style="display:flex;"><span>	.......
</span></span><span style="display:flex;"><span>	<span style="color:#cdcd00">case</span> LUA_GCSTEP: {
</span></span><span style="display:flex;"><span>      <span style="color:#00cd00">int</span> data <span style="color:#39c">=</span> va_arg(argp, <span style="color:#00cd00">int</span>);
</span></span><span style="display:flex;"><span>      l_mem debt <span style="color:#39c">=</span> <span style="color:#cd00cd">1</span>;  <span style="color:#000080">/* =1 to signal that it did an actual step */</span>
</span></span><span style="display:flex;"><span>      lu_byte oldstp <span style="color:#39c">=</span> g<span style="color:#39c">-&gt;</span>gcstp;
</span></span><span style="display:flex;"><span>      g<span style="color:#39c">-&gt;</span>gcstp <span style="color:#39c">=</span> <span style="color:#cd00cd">0</span>;  <span style="color:#000080">/* allow GC to run (GCSTPGC must be zero here) */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#cdcd00">if</span> (data <span style="color:#39c">==</span> <span style="color:#cd00cd">0</span>) {
</span></span><span style="display:flex;"><span>        luaE_setdebt(g, <span style="color:#cd00cd">0</span>);  <span style="color:#000080">/* do a basic step */</span>
</span></span><span style="display:flex;"><span>        luaC_step(L);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#cdcd00">else</span> {  <span style="color:#000080">/* add &#39;data&#39; to total debt */</span>
</span></span><span style="display:flex;"><span>        debt <span style="color:#39c">=</span> cast(l_mem, data) <span style="color:#39c">*</span> <span style="color:#cd00cd">1024</span> <span style="color:#39c">+</span> g<span style="color:#39c">-&gt;</span>GCdebt;
</span></span><span style="display:flex;"><span>        luaE_setdebt(g, debt);
</span></span><span style="display:flex;"><span>        luaC_checkGC(L);<span style="color:#000080">///这个地方触发
</span></span></span><span style="display:flex;"><span><span style="color:#000080"></span>      }
</span></span><span style="display:flex;"><span>      g<span style="color:#39c">-&gt;</span>gcstp <span style="color:#39c">=</span> oldstp;  <span style="color:#000080">/* restore previous state */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#cdcd00">if</span> (debt <span style="color:#39c">&gt;</span> <span style="color:#cd00cd">0</span> <span style="color:#39c">&amp;&amp;</span> g<span style="color:#39c">-&gt;</span>gcstate <span style="color:#39c">==</span> GCSpause)  <span style="color:#000080">/* end of cycle? */</span>
</span></span><span style="display:flex;"><span>        res <span style="color:#39c">=</span> <span style="color:#cd00cd">1</span>;  <span style="color:#000080">/* signal it */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#cdcd00">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	.......
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>比如<code>lua</code>层调用<code>collectgarbage(&quot;step&quot;)</code>语句的时候,就会调用到这里来,等价于手动单步运行垃圾回收</p>
<p>不管是手动还是自动触发,只要是设置的增量GC方式都会进入<code>singlestep</code>函数</p>
<p><img loading="lazy" src="image-20230219211431660.png" alt="image-20230219211431660"  />
</p>
<p><code>singlestep</code>函数就是增量GC的主力函数,因为前面参数的设置调控和<code>singlestep</code>函数内部的逻辑处理,就可以实现增量处理,可以被中断再恢复并继续进行,不会在像<code>双色GC</code>程序必须暂停下来,不能进行其他操作导致卡顿</p>
<h5 id="开始阶段gcspause"><span>开始阶段:GCSpause</span></h5>
<p><img loading="lazy" src="image-20230219212531926.png" alt="image-20230219212531926"  />
</p>
<p>从上面可以看出这个阶段主要靠<code>restartcollection</code>函数处理相关逻辑</p>
<p><img loading="lazy" src="image-20230219212643018.png" alt="image-20230219212643018"  />
</p>
<p><img loading="lazy" src="image-20230219212733415.png" alt="image-20230219212733415"  />
</p>
<p>进入函数中,我们可以看到这个函数主要是处理了这些事情</p>
<ul>
<li>
<p>将<code>g-&gt;gray</code>灰色节点链 <code>g-&gt;grayagain</code>原子操作灰色节点链表初始化</p>
</li>
<li>
<p>将<code>3</code>个和弱表相关的链表初始化</p>
</li>
<li>
<p>将<code>mainthread:主执行栈</code>,<code>l_registry:全局注册表</code>,<code>markmt(g):全局元表</code>,<code>markbeingfnz(g):上次GC循环中剩余的finalize中的userdata对象</code>在此进行标记</p>
</li>
<li>
<p>而对对象进行标记是由<code>reallymarkobject</code>函数进行的</p>
<p><code>reallymarkobject</code> 主要逻辑是直接将 <code>userdata</code>, <code>string</code>, <code>closed upvalue</code> 涂黑, 其它类型对象<code>涂灰</code>等待进一步处理</p>
<p><img loading="lazy" src="image-20230219212817095.png" alt="image-20230219212817095"  />
</p>
<p>当这些都处理完以后就进入了<code>传播阶段:GCSpropagate</code></p>
</li>
</ul>
<h5 id="传播阶段gcspropagate"><span>传播阶段:GCSpropagate</span></h5>
<p><img loading="lazy" src="image-20230219214212638.png" alt="image-20230219214212638"  />
</p>
<p>从上图中我们可以看到,如果<code>g-&gt;gray</code>不等于空,那么就会一直调用<code>propagatemark</code>函数从灰色列表中取出一个灰色对象进行涂黑,并对他的引用进行标记,还有注意这里并不是一个循环一直在循环调用<code>propagatemark</code>函数进行循环取灰色对象,进行标记,而只有<code>g-&gt;gray==NULL</code>的时候才会进入下一次<code>GC</code>阶段,由此我们可以看出这个是可以被中断的,毕竟<code>propagatemark</code>函数中有<code>g-&gt;gray</code>指针一直记录这执行到了那一个灰色对象,在下次进来的时候从这个地方在开始执行就行了,这样做能有效的减少阻塞时间,更快的响应<code>Lua</code>虚拟机,毕竟谁也不想一直把性能处理长时间丢到这快地方,当<code>gray</code>链表当中的灰色节点处理完以后,就会进入<code>GCSatomic的过渡状态:GCSenteratomic</code></p>
<p>从上面其实我们还可以分析出,如果一直在创建对象,创建对象的速度一直大于<code>GCSpropagate</code>的处理速度,那么就会导致一直卡在这里</p>
<p>解决这个办法,可以有如下方法</p>
<ul>
<li>一个是减少<code>gray</code>链表的数量,也就是减少灰色节点的创建,比如少弄一层又一层的引用,举个例子比如你创建了一个<code>table</code>,然后<code>table</code>的<code>value</code>又没有设置<code>week</code>,那么就会变量<code>table</code>中<code>table</code>所有可达的<code>value</code>,如果<code>value</code>是<code>GC</code>对象并且是白色的,那么就会有<code>push</code>到灰色链表当中,这样就子子孙孙无穷尽也,很有可能一直卡在这一块</li>
<li>第二中方法的话可以控制<code>GC</code>的各种阈值变量
<ul>
<li>比如通过调用<code>collectgarbage(&quot;setstepmul&quot;)</code>调节<code>gcstepmul</code>阈值变量,让他变小一点,这样就缩小了一步处理<code>GC</code>的工作量,从而减少处理时间</li>
<li>还可以调用<code>collectgarbage(&quot;setpause&quot;)</code>调节<code>gcpause</code>阈值变量,让他变小点,加快第二次<code>GC</code>开始到来的时间</li>
</ul>
</li>
</ul>
<p>上面介绍完,我们在来好好的讲解下<code>propagatemark</code>函数里面到底做了啥</p>
<p><img loading="lazy" src="image-20230219224908858.png" alt="image-20230219224908858"  />
</p>
<h6 id="标记tabletraversetable"><span>标记table:traversetable</span></h6>
<p><img loading="lazy" src="image-20230219225103093.png" alt="image-20230219225103093"  />
</p>
<p>从上图中我们可以分析出主要是通过扫描<code>table类型</code>,<code>key,value的类型</code>,<code>是不是weak方式</code>,决定放入那个全局虚拟机<code>GC</code>链表</p>
<ol>
<li>
<p><code>strong key, weak value</code></p>
<p>若 <code>gc</code> 处在 <code>GCSpropagate </code>阶段, 并且<code>g-&gt;gray</code>不为空将 <code>weak table</code> 加入到<code> g-&gt;grayagain</code> 链表中, 在 <code>atomic phase </code>再次访问</p>
<p>否则按下面的规则添加到对应链表</p>
<ol>
<li><code>table</code>数组部分
<ul>
<li>
<p>若<code>table</code>数组部分中有元素, 并且是<code>atomic phase</code>阶段加入到<code> g-&gt;weak list</code></p>
</li>
<li>
<p>若<code>table</code>数组部分中没有元素 并且不是<code>atomic phase</code>阶段加入到 <code>g-&gt;grayagain list</code></p>
</li>
</ul>
</li>
<li><code>table hash</code>部分
<ul>
<li>
<p><code>val is nil</code>: 移除它</p>
</li>
<li>
<p><code>val is not nil</code>: 标记<code>key</code>,若<code>value is</code>白色 (且不为不可回收对象)</p>
<ul>
<li>是<code>atomic phase</code>阶段加入到 <code>g-&gt;weak list</code></li>
<li>不是<code>atomic phase</code>阶段加入到 <code>g-&gt;grayagain list</code></li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p><code>weak key, strong value</code></p>
<ol>
<li>
<p><code>table</code>数组部分</p>
<p>遍历数组如果有白色值就进行标记,并<code>marked</code>设置为<code>true</code></p>
</li>
<li>
<p><code>table hash</code>部分</p>
<p>按倒序或者正序遍历进行标记,标记好以后进行如下操作</p>
<p>若<code>gc</code> 处在<code>GCSpropagate</code>: 把<code>h</code>放入<code>g-&gt;grayagain</code>中</p>
<p>否则按如下规则处理</p>
<p>​    <code>val is nil</code>:  移除它</p>
<p>​    <code>white key-white value</code>:  把h放入<code>g-&gt;ephemeron</code></p>
<p>​    <code>white key-marked value</code>: 把<code>h</code>放入<code>g-&gt;allweak</code></p>
<p>​    <code>marked key-white value</code>: 标记<code>value</code></p>
<p>​    <code>其他</code>:如果是<code>touched1</code>状态把黑色对象<code>link</code>进灰色链表,否则如果是<code>touched2</code>状态改变他的年龄到<code>G_OLD</code></p>
</li>
</ol>
</li>
</ol>
<p>3.<code>weak key, weak value</code></p>
<p>把<code>table</code>放入<code>g-&gt;allweak</code></p>
<ol start="4">
<li>
<p><code>strong key, strong value</code></p>
</li>
<li>
<p><code>table</code>数组部分</p>
<p>对<code>value</code>进行标记</p>
</li>
<li>
<p><code>table hash</code>部分</p>
<p><code>value is nil</code>: 移除它</p>
<p><code>value is not nil</code>: 标记<code>key</code>, 标记<code>value</code></p>
</li>
</ol>
<h6 id="标记userdatatraverseudata"><span>标记userdata:traverseudata</span></h6>
<p><img loading="lazy" src="image-20230219231342086.png" alt="image-20230219231342086"  />
</p>
<p>可以看到主要的事情是对<code>userdata</code>里面的元表和上值进行标记</p>
<h6 id="标记lua闭包traverselclosure"><span>标记lua闭包:traverseLclosure</span></h6>
<p><img loading="lazy" src="image-20230219231557893.png" alt="image-20230219231557893"  />
</p>
<p>可以看到主要的事情是对<code>lua闭包</code>里面的引用对象函数原型和上值进行标记</p>
<h6 id="标记c闭包traversecclosure"><span>标记C闭包:traverseCclosure</span></h6>
<p><img loading="lazy" src="image-20230219231732155.png" alt="image-20230219231732155"  />
</p>
<p>主要是标记<code>C</code>闭包里面所有的上值</p>
<h6 id="标记函数原型traverseproto"><span>标记函数原型:traverseproto</span></h6>
<p><img loading="lazy" src="image-20230219231846070.png" alt="image-20230219231846070"  />
</p>
<p>主要是标记函数原型里面引用的<code>文件名</code>,<code>常量表</code>,<code>上值名</code>,<code>子函数表</code>,<code>局部变量</code></p>
<h6 id="标记线程traversethread"><span>标记线程:traversethread</span></h6>
<p><img loading="lazy" src="image-20230219232245634.png" alt="image-20230219232245634"  />
</p>
<ul>
<li>
<p>如果现在<code>GC</code>是<code>GCSpropagate</code>阶段,线程也是旧对象,那么就丢到<code>g-&gt;grayagain</code>列表放在后面<code>atomic</code>中进行处理,毕竟<code>thread</code>上关联的对象是<code>Lua</code>运行时的状态,变化很频繁,还不如丢到<code>grayagin</code>表中然后到<code>atomic</code>一次性进行标记处理</p>
</li>
<li>
<p>如果现在<code>GC</code>是<code>GCSatomic</code>阶段</p>
<p>清除已经不在使用的栈空间,并把它们置成<code>nil</code></p>
</li>
<li>
<p>如果线程的上值<code>open</code>链表有值</p>
<p>标记上值<code>open</code>链表</p>
</li>
<li>
<p>如果线程在<code>twups</code>链表中</p>
<p>若 <code>thread</code> 不在<code>twups</code>链表中,但是 上面有<code>openupval</code>, 则将其重新加入到 <code>g-&gt;twups</code> 链表</p>
</li>
</ul>
<h6 id="其他类型"><span>其他类型</span></h6>
<p>就是简单的调用<code>nw2black(o)</code>函数标记成黑色</p>
<h6 id="屏障操作"><span>屏障操作</span></h6>
<ol>
<li>
<p><code>luaC_barrier</code></p>
<p><img loading="lazy" src="image-20230220001617165.png" alt="image-20230220001617165"  />
</p>
<p><img loading="lazy" src="image-20230220001633615.png" alt="image-20230220001633615"  />
</p>
<p>向前走一步如果新建对象是白色,而它被一个黑色对象引用了那么将这个新建对象颜色从白色变为灰色</p>
<p>这么做的主要是因为</p>
<ol>
<li>在赋值操作的时候有可能发生黑色对象,指向白色对象的可能性,出现这种情况是不合法的,毕竟如果你一个黑色对象指向了白色对象,比如 <code>lua_load</code> 函数当中的  <code>luaC_barrier(L, f-&gt;upvals[0], gt)</code>执行语句如果不把gt从白色变成灰色,那么在<code>lua GC</code>状态机持续运转中到达回收状态中会把他当白色对象给回收了,那这样就会导致函数的上值表第一个位置存的元素消失,这样肯定是不合理的</li>
<li>也是为了让<code>GC</code>能够感知到你这个黑色对象重新赋值了一个白色对象,如果你不把这个黑色对象新引用的白色对象不改变颜色的话,很有可能在传播阶段和原子阶段因为这个白色对象不在<code>gray</code>链表中无法感知而无法标识这个白色节点引用的东西导致错误</li>
</ol>
</li>
<li>
<p><code>luaC_barrierback</code></p>
<p><img loading="lazy" src="image-20230220002957919.png" alt="image-20230220002957919"  />
</p>
<p>标记向后一步此时将引用的它的黑色对象的颜色从黑色变为灰色,然后放入<code>grayagain</code>链表当中</p>
<p>通过观察我们看到这个操作主要是给<code>table</code>使用的</p>
<p>主要原因是</p>
<ul>
<li><code>table</code>关联的对象<code>key,value</code>是一对多的关系,如果调用的是向前操作,那么如果加入一个数据,那么就的放入<code>gray</code>链表中去等待扫描,如果引用的层级特别的多,可想而知,这样一直遍历<code>gray</code>链表,等待时间会非常长,增加不必要的开销,还不如向后一步,直接放入<code>grayagain</code>链表在原子阶段直接一次性标记扫描</li>
</ul>
</li>
</ol>
<p>接下来如果<code>gray</code>链表都标记清除处理完毕了,那么就进入了<code>过渡阶段:GCSenteratomic</code></p>
<h5 id="过渡阶段gcsenteratomic"><span>过渡阶段:GCSenteratomic</span></h5>
<p><img loading="lazy" src="image-20230219223700393.png" alt="image-20230219223700393"  />
</p>
<p>这个阶段没太多可讲的主要是两个重要函数</p>
<ul>
<li><code>atomic</code>:进入原子收集标记阶段</li>
<li><code>entersweep</code>: <code>sweep</code>过程中把非<code>dead</code> 对象标记为 <code>currentwhite </code></li>
</ul>
<p>上面两个函数也留到下一个阶段<code>原子阶段:GCSatomic</code>来讲解</p>
<h5 id="原子阶段gcsatomic"><span>原子阶段:GCSatomic</span></h5>
<p><img loading="lazy" src="image-20230219235911014.png" alt="image-20230219235911014"  />
</p>
<p>从上面的函数这次集中处理的是<code>运行中的协程栈</code> <code>全局注册表</code> <code>全局元表</code> <code>open状态的上值</code> <code>grayagain链表</code> <code>弱表链表</code> <code>所有准备终结的userdata对象</code> 可以看出这次在遍历未处理的数据的时候,是一次性执行的,每一次遍历未处理的数据,都会再次调用<code>propagateall</code>函数以保证这次彻底的把<code>gray</code>链表访问到了</p>
<p>然后将当前白色值切换到新一轮的白色值(在此之后,所有新建的对象虽然也为白色,但是在<code>GC</code>循环走完之前并不会被回收,而是等待下一轮<code>GC</code>回收)</p>
<p><img loading="lazy" src="image-20230220000206896.png" alt="image-20230220000206896"  />
</p>
<p>原子<code>atomic</code>处理完以后又会调用<code>entersweep</code>函数进入扫描复活模式,主要作用还是为了把这次<code>GC</code>中死亡的对象回收,未死亡的对象设置成当前白</p>
<p><img loading="lazy" src="image-20230220001259074.png" alt="image-20230220001259074"  />
</p>
<p>上述步骤终于做完了,我们就可以进行下一步来到回收阶段了</p>
<h5 id="清扫阶段"><span>清扫阶段</span></h5>
<p><img loading="lazy" src="image-20230220092723559.png" alt="image-20230220092723559"  />
</p>
<p><code>sweepstep</code>函数最终会调用到<code>sweeplist</code>函数,而<code>sweeplist</code>函数上面也介绍过主要是为了把死对象回收,把非死对象标记为当前白</p>
<h6 id="gcsswpallgc"><span>GCSswpallgc</span></h6>
<p><img loading="lazy" src="image-20230220093308699.png" alt="image-20230220093308699"  />
</p>
<p>从上图函数中可以看出<code>g-&gt;sweepgc</code>指针执行的是<code>g-&gt;allgc,</code>所以这里的作用主要就是扫描<code>g-&gt;allgc</code>,并把里面的死对象回收,非死亡对象标记为当前白</p>
<h6 id="gcsswpfinobj"><span>GCSswpfinobj</span></h6>
<p><code>GCSswpfinobj</code>同样也调用了<code>sweeplist</code>进行清除并且标记,主要是对<code>global_State.finobj</code>链表的处理,而前面我们也分析过<code>finobj</code>里面存的是什么东西</p>
<p><img loading="lazy" src="image-20230220093720397.png" alt="image-20230220093720397"  />
</p>
<p>从上面可以看出他除了清扫并标记,还做了对自定义<code>__gc</code>元方法调用</p>
<h6 id="gcsswptobefnz"><span>GCSswptobefnz</span></h6>
<p><code>GCSswpfinobj</code>同样也调用了<code>sweeplist</code>进行清除并且标记,,主要是对<code>global_State.tobefnz</code>链表的处理,<code>tobefinz</code>里面存的内容主要<code>userdata</code>对象相关</p>
<p><img loading="lazy" src="image-20230220094253570.png" alt="image-20230220094253570"  />
</p>
<h6 id="gcsswpend"><span>GCSswpend</span></h6>
<p><img loading="lazy" src="image-20230220094349509.png" alt="image-20230220094349509"  />
</p>
<p><code>GCSswpend</code>最后回收结尾,主要是针对内存的回收,整理,字符串表的收缩,还有存活量的统计</p>
<h5 id="收尾阶段gcscallfin"><span>收尾阶段:GCScallfin</span></h5>
<p><img loading="lazy" src="image-20230220094718698.png" alt="image-20230220094718698"  />
</p>
<p><img loading="lazy" src="image-20230220094746972.png" alt="image-20230220094746972"  />
</p>
<p>这是最后状态机的最后一步了,主要会对<code>global_State.tobefnz</code>链表进行遍历,然后调用<code>userdata</code>自己定义的<code>__gc</code>元方法,来进行自己的自定义回收,同时还会将<code>tobefnz</code>链表中的对象放到<code>allgc</code>链表中,参与下一次<code>GC</code>回收流程</p>
<h4 id="分代gc"><span>分代gc</span></h4>
<p>时间关系,下周补全</p>
<h4 id="gc通过那些阈值进行调控"><span>GC通过那些阈值进行调控</span></h4>
<p>时间关系,下周补全</p>
<h2 id="更详细的注释请去我的github地址"><span>更详细的注释请去我的GitHub地址</span></h2>
<p>以下是我几乎每行都加了注释的<code>GitHub</code>地址</p>
<ol>
<li>
<p><code>lgc.c</code>注释地址</p>
<p><a href="https://github.com/frog-game/lua-5.4.4-comments/blob/master/src/lgc.c"><strong>lgc.c注释</strong></a></p>
</li>
<li>
<p><code>lgc.h</code>注释地址</p>
<p><a href="https://github.com/frog-game/lua-5.4.4-comments/blob/master/src/lgc.h"><strong>lgc.h注释</strong></a></p>
</li>
</ol>


        </div>
        <div class="post-reward">
            <div style="padding: 0 0 0 0; margin: 0 0 0 0; width: 100%; font-size:16px; text-align: center;">
                <div id="QR" style="opacity: 0;">
                    <div id="wechat" style="display: inline-block">
                        <a class="fancybox" rel="group">
                            <img id="wechat_qr" src="https://frog-game.github.io/img/wechat_pay.png" alt="wechat_pay"></a>
                        <p>微信</p>
                    </div>
                    <div id="alipay" style="display: inline-block">
                        <a class="fancybox" rel="group">
                            <img id="alipay_qr" src="https://frog-game.github.io/img/alipay_pay.png" alt="alipay"></a>
                        <p>支付宝</p>
                    </div>
                </div>
                <button id="rewardButton"
                        onclick="
                    var qr = document.getElementById('QR');
                    if (qr.style.opacity === '0') {
                        qr.style.opacity='1';
                    } else {
                        qr.style.opacity='0'
                    }"
                >
                    <span>🧧 鼓励</span>
                </button>
            </div>
        </div>

        <footer class="post-footer">
            
<nav class="paginav">
  <a class="next" href="https://frog-game.github.io/posts/read/lua5.4.4.stack/">
    <span class="title">下一页 »</span>
    <br>
    <span>[Lua5.4.4源码].栈</span>
  </a>
</nav>

        </footer>
    </div>



<div>
    <div class="pagination__title">
        <span class="pagination__title-h" style="font-size: 20px;">💬评论</span>
        <hr />
    </div>

    <div id="tcomment"></div>

    <script src="https://cdn.staticfile.org/twikoo/1.6.7/twikoo.all.min.js">
    </script>
    

    

    <script>
        twikoo.init({
            envId: "https://www.frog-game.work/", 
            el: "#tcomment",
            lang: 'zh-CN',
            region: "ap-beijing",
            path: window.TWIKOO_MAGIC_PATH||window.location.pathname,
            
            
            
            
            
            
            
        });
    </script>

</div>
</article>
</main>


<script async src="https://unpkg.com/mermaid@8.8.1/dist/mermaid.min.js"></script>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<footer class="footer">
    <span>
        Copyright
        &copy;
        2020-2023 
        <a href="https://frog-game.github.io/" style="color:#939393;">frog&#39;s Blog</a>
         All Rights Reserved
    </span>

    <a href="https://beian.miit.gov.cn/" target="_blank" style="color:#939393;">备案号</a>&nbsp;

    <span>
        <a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=null"style="display:inline-block;text-decoration:none;height:20px;color:#939393;">
            <img src="https://frog-game.github.io/img/beian.png" style="float:left;margin: 0px 5px 0px 0px;"/>
            公网安备
        </a>
    </span>

    <span id="busuanzi_container">
        <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
        总访客数: <span id="busuanzi_value_site_uv"></span>
        总访问量: <span id="busuanzi_value_site_pv"></span>
    </span>
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <span class="topInner">
        <svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z"/>
        </svg>
        <span id="read_progress"></span>
    </span>
</a>

<script>
    document.addEventListener('scroll', function (e) {
        const readProgress = document.getElementById("read_progress");
        const scrollHeight = document.documentElement.scrollHeight;
        const clientHeight = document.documentElement.clientHeight;
        const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        
        readProgress.innerText = ((scrollTop / (scrollHeight - clientHeight)).toFixed(2) * 100).toFixed(0);
    })
</script>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 400 || document.documentElement.scrollTop > 400) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>

<script>
    document.body.addEventListener('copy', function (e) {
        if (window.getSelection().toString() && window.getSelection().toString().length > 50) {
            let clipboardData = e.clipboardData || window.clipboardData;
            if (clipboardData) {
                e.preventDefault();
                let htmlData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"frog's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                    '\r\n原文链接：' + location.href;
                let textData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"frog's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                    '\r\n原文链接：' + location.href;
                clipboardData.setData('text/html', htmlData);
                clipboardData.setData('text/plain', textData);
            }
        }
    });
</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = '📄复制';

        function copyingDone() {
            copybutton.innerText = '👌🏻已复制!';
            setTimeout(() => {
                copybutton.innerText = '📄复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                let text = codeblock.textContent +
                    '\r\n————————————————\r\n' +
                    '版权声明：本文为「'+"frog's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                    '\r\n原文链接：' + location.href;
                navigator.clipboard.writeText(text);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) {
            }
            ;
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
