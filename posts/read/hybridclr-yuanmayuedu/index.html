<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>HybridCLR-源码阅读 | frog&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="对HybridCLR源码的深度阅读,理解,分析,源码进行注释">
<meta name="author" content="
作者:&nbsp;frog">
<link rel="canonical" href="https://frog-game.github.io/posts/read/hybridclr-yuanmayuedu/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8b1bcfe952e1e1a78b44fa99f358fddf187aee65873bbc85ca10d6f18a3bff33.css" integrity="sha256-ixvP6VLh4aeLRPqZ81j93xh67mWHO7yFyhDW8Yo7/zM=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
        onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://frog-game.github.io/img/Q.gif">
<link rel="icon" type="image/png" sizes="16x16" href="https://frog-game.github.io/img/Q.gif">
<link rel="icon" type="image/png" sizes="32x32" href="https://frog-game.github.io/img/Q.gif">
<link rel="apple-touch-icon" href="https://frog-game.github.io/img/Q.gif">
<link rel="mask-icon" href="https://frog-game.github.io/img/Q.gif">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = ""; 
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<meta property="og:title" content="HybridCLR-源码阅读" />
<meta property="og:description" content="对HybridCLR源码的深度阅读,理解,分析,源码进行注释" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://frog-game.github.io/posts/read/hybridclr-yuanmayuedu/" />
<meta property="og:image" content="https://frog-game.github.io/posts/read/hybridclr-yuanmayuedu/image-20221204163813761.png" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-19T01:30:29&#43;08:00" />
<meta property="article:modified_time" content="2022-12-19T01:30:29&#43;08:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://frog-game.github.io/posts/read/hybridclr-yuanmayuedu/image-20221204163813761.png" />
<meta name="twitter:title" content="HybridCLR-源码阅读"/>
<meta name="twitter:description" content="对HybridCLR源码的深度阅读,理解,分析,源码进行注释"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "📚文章",
      "item": "https://frog-game.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "📕 阅读",
      "item": "https://frog-game.github.io/posts/read/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "HybridCLR-源码阅读",
      "item": "https://frog-game.github.io/posts/read/hybridclr-yuanmayuedu/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "HybridCLR-源码阅读",
  "name": "HybridCLR-源码阅读",
  "description": "对HybridCLR源码的深度阅读,理解,分析,源码进行注释",
  "keywords": [
    ""
  ],
  "articleBody": "一些前提知识点 代码术语区别 IL:微软平台上的一门中间语言，我们常写的C#代码在编译器中都会自动转换成IL,中间语言是编译使用高级 .NET 语言编写的代码后获得的结果。 对使用其中一种语言编写的代码进行编译后，即可获得 IL 所生成的二进制代码\n托管代码：托管代码就是执行过程交由运行时管理的代码。 在这种情况下，相关的运行时称为公共语言运行时 (CLR)，不管使用的是哪种实现（例如 Mono、.NET Framework 或 .NET Core/.NET 5+）。 CLR 负责提取托管代码、将其编译成机器代码，然后执行它。 除此之外，运行时还提供多个重要服务，例如自动内存管理、安全边界、类型安全，把托管代码理解成上面的IL中间语言也行\n非托管代码：非托管代码（Unmanaged Code）是指直接编译成目标计算机的机器码，这些代码只能运行在编译出这些代码的计算机上，或者是其他相同处理器或者几乎一样处理器的计算机上。非托管代码不能享受公共语言运行库所提供的一些服务，例如内存管理、安全管理等。非托管代码（Unmanaged Code）不由CLR公共语言运行库执行，而是由操作系统直接执行的代码,如果非托管代码需要进行内存管理等服务，就必须显式地调用操作系统的接口，通常非托管代码调用Windows SDK所提供的API来实现内存管理。\n原生代码:native code是本地cpu的目标执行代码, 不是IL, 所以速度很快, 它的执行不依赖某个虚拟机或者解释器，编译后可直接依附操作系统运行，不需要经过虚拟机之类的东西\n程序集:程序集（Assembly）的文件负责封装中间语言，程序集中包含了描述所创建的方法、类以及属性的所有元数据\n编译器 c#编译器: 将c#编译为IL [C#----\u003eCIL] Mono Runtime编译器:将IL转换成原生码，然后让Mono运行时去执行,这样其实也达到了c#跨平台的效果 平台编译 build\n编译GCC的平台\nhost\n运行GCC的平台\ntarget\nGCC编译产生的应用程序的运行平台\nnative compiler:三者全部相同（build = host = target）就是原生编译 我们在PC上装的Ubuntu或者Fedora里面带的GCC，就是native compiler cross compile:如果build = host，但是target跟前两者不同就是 交叉编译开发手机应用程序的编译器，通常运行在PC或Mac上，但是编译出来的程序无法直接在PC或Mac上执行 编译方式 即时编译[Just in time, JIT]: 就是在程序运行的时候把CIL的byte code 转成目标平台的原生码,也就是Mono Runtime编译器干的活 提前编译[Ahead of time,AOT]:程序运行前将exe或者dll里面的CIL的byte code部分转成目标平台的原生码,并且存储起来，好加快速度,但是程序中还是会有部分的CIL的byte code需要JIT编译 完全静态编译[Full ahead of time,Full-AOT]:就是将所有源码编译成目标平台所需要的原生码 IOS不支持JIT编译的原因 IOS并非把JIT禁止了，主要还是IOS封存了内存的[可执行权限]，变相的封锁了JIT编译方式 值类型和引用类型 C# 中的类型一共分为两类，一类是值类型(Value Type)，一类是引用类型(Reference Type)。\n值类型包括结构体(struct)和枚举(enum)。 引用类型包括类(class)、接口(interface)、委托(delegate)、数组(array)等。\n常见的简单类型如short、int、long、float、double、byte、char等其本质上都是结构体，对应struct System.Int16、System.Int32、System.Int64、System.Single、System.Double、Syetem.Byte、System.Char，因此它们都是值类型。但string和object例外，它们本质上是类，对应class System.String和System.Object，所以它们是引用类型。\n值类型 值类型变量本身保存了该类型的全部数据，当声明一个值类型的变量时，该变量会被分配到栈(Stack)上。\n引用类型 引用类型变量本身保存的是位于堆(Heap)上的该类型的实例的内存地址，并不包含数据。当声明一个引用类型变量时，该变量会被分配到栈上。如果仅仅只是声明这样一个变量，由于在堆上还没有创建该类型的实例，因此，变量值为null，意思是不指向任何类型实例(堆上的对象)。对于变量的类型声明，用于限制此变量可以保存的类型。\n值传递和引用传递 C#中方法的参数传递默认的是值传递，引用传递和输出传递需要在参数类型前面对应加上ref、out限制符，由于输出传递和引用传递类似，这里只讨论引用传递。\n值传递参数是原变量的拷贝，值传递参数和原变量的内存地址不同，因此方法中对值传递参数的修改不会改变原变量。\n引用传递参数是原变量的指针，引用传递参数和原变量的内存地址相同，相应的方法中对引用传递参数的修改会改变原变量。\nHybridCLR菜单 IL2CPP 就是上面的2.1编译方式中的AOT提前编译\n分为下面两部分 AOT编译器 ​\t把IL中间语言转成CPP文件的作用\n运行时库 ​\t主要是做垃圾回收,线程文件的获取，还有对托管数据的原生代码进行修改\n为啥要转换成CPP 运行速度快,这个毋庸置疑 mono 为了跨平台，他是通过VM来实现的，也就是说有几个平台，就需要实现几个VM,这种方法耗时耗力,而且为了实现各个平台的支持和移植，势必要把代码进行修改，然后出现bug在进行修复，来来回回时间和精力花费不少，所以为啥不利用现成各个平台的C++编译器执行了,这也是IL2CPP的核心思想 虽然最后代码都变成的静态的C++但是内存管理这块还是需要遵循c#的标准和方式,这也是为什么最后还需要一个 IL2CPP VM的原因 这个时候VM做得主要还是GC的管理,线程的创建等等一些辅助服务性的工作 工作原理就直接上官网的图了 为什么IL2CPP不支持热更新 因为IL2CPP是一个纯静态的AOT运行时，然后不支持运行时加载DLL，所以是不支持热更新\n然后hybridclr扩充了IL2CPP的代码,使他从AOT运行方式变成了AOT+Interpreter的混合方式从而可以动态的加载dll实现热更新\n区别 原始IL指令集是基于栈的指令集\nHybridclr是基于寄存器指令\n两种方式各有优缺点，基于栈的指令集很明显可移植高，但是工作效率较低。而基于寄存器指令集寄存器由硬件直接提供，工作效率高，程序受硬件约束。\nHybridclr的原理 dll不过是元数据和代码的集合,aot与 热更新dll的区别只不过一个函数以aot代码方式执行，一个以解释方式执行,最后都会直接在虚拟机层面将aot和热更新dll统一对待\n为什么Hybridclr能做到如此统一和彻底，因为元数据不过是数据，不管aot还是热更新是没有本质区别的\n而托管代码执行，依赖的不过是代码和数据\nHybridclr分两个工程\nHybridclr工程进行了源码的编译解析，在这里可以理解成这个工程做得主要事情是解释器的工作,此解释器是在IL2CPP VM扩充的，不解的可以看下图\n第二个工程是il2cpp_plus,这个工程会把泛型方法、泛型数据类型、以及其他的一些支持添加到IL2CPP里面,也可以简单的理解成为主要是为了给IL2CPP扩展功能用的，从而能让他动态的加载DLL\n源码解析 Hybridclr工程 这个是代码工程结构\n阅读前提 ARM64:CPU的ARM架构 主流的手机/平板品牌，绝大数是采用ARM架构\nBoehmGC算法，unity底层托管堆使用的是BoehmGC算法是用的mark-sweep（标记-清扫）算法,具体和Java的gc算法类型,这块由于篇幅问题就不详细写了,太多内容一句话说不清楚,以后有时间整理一篇详细文章出来\nModule 是 .dll 或 .exe 类型的可移植可执行文件，这些文件由一个或多个类和接口组成\nAssembly 是程序集\nAssembly有main程序函数。module只能附属于程序集，程序集可以拥有多个。\nMetaData就是用System.reflection得到的方法，属性，参数等等，这些都是**元数据**\nMethodBody 方法主体，就是**调用方法时执行的代码块**，方法的主体语句必须放在花括号（即大括号 {}）中。\nIl2CppImage 这个结构体是程序集镜像,可以通过它来获取命名空间,class,方法,函数指针地址等等\ntypedef struct Il2CppImage { const char* name;//名字 const char *nameNoExt;//扩展名字 Il2CppAssembly* assembly;//程序集指针 TypeDefinitionIndex typeStart;//方法类型偏移位置开始 uint32_t typeCount;//方法总数 TypeDefinitionIndex exportedTypeStart;//导出类型偏移位置开始 uint32_t exportedTypeCount;//导出类型总数 CustomAttributeIndex customAttributeStart;//自定义属性偏移位置开始 uint32_t customAttributeCount;//自定义属性总数 MethodIndex entryPointIndex;//方法入口点索引 #ifdef __cplusplus mutable #endif Il2CppNameToTypeDefinitionIndexHashTable * nameToClassHashTable;//name对应的class的hashTable const Il2CppCodeGenModule* codeGenModule;//Module指针 uint32_t token;//通过他可以得到函数指针地址 uint8_t dynamic;//没看到使用,估计是用来验证是不是动态lib使用的 } Il2CppImage; 所有的metadata 解析都是遵循的下面规范ECMA-335 - Ecma International (ecma-international.org)\nCLI中大多数metadata被为几十种类型，每个类型的数据组织成一个table如下图,如果有缺失类型,请去ECMA-335查看\nPortable PDB tables .NET引入了一种新的符号文件（PDB）格式，主要用于跨平台\n早期PDB格式是为了C和C++设计的，发展了多年以来现在已经支持.NET了。不幸的是，这种格式一直以来都被认为是专有的，这就意味着它没有很好文档记录，而且只能使用Windows库读取，所以有了.NET Core，而且为了跨平台，于是开发了这个新的跨平台PDB库\n原始 MethodInfo\ntypedef struct MethodInfo { Il2CppMethodPointer methodPointer;//指向普通执行函数 InvokerMethod invoker_method;//指向反射执行函数 const char* name;//名字 Il2CppClass *klass;//函数所属类指针 const Il2CppType *return_type;//返回值类型 const ParameterInfo* parameters;//参数信息 union//generic instance method { const Il2CppRGCTXData* rgctx_data; /* is_inflated is true and is_generic is false, i.e. a generic instance method */ const Il2CppMethodDefinition* methodDefinition;//方法定义 }; union//uninflated generic method { const Il2CppGenericMethod* genericMethod; /* is_inflated is true */ const Il2CppGenericContainer* genericContainer; /* is_inflated is false and is_generic is true */ }; uint32_t token; uint16_t flags; uint16_t iflags; uint16_t slot; uint8_t parameters_count; uint8_t is_generic : 1; /* true if method is a generic method definition */ uint8_t is_inflated : 1; /* true if declaring_type is a generic instance or if method is a generic instance*/ uint8_t wrapper_type : 1; /* always zero (MONO_WRAPPER_NONE) needed for the debugger */ uint8_t is_marshaled_from_native : 1; /* a fake MethodInfo wrapping a native function pointer */ } MethodInfo; 改写后的MethodInfo\ntypedef struct MethodInfo { Il2CppMethodPointer methodPointer; InvokerMethod invoker_method; const char* name; Il2CppClass *klass; const Il2CppType *return_type; const ParameterInfo* parameters; union { const Il2CppRGCTXData* rgctx_data; /* is_inflated is true and is_generic is false, i.e. a generic instance method */ const Il2CppMethodDefinition* methodDefinition; const Il2CppMethodDefinition* methodMetadataHandle; }; /* note, when is_generic == true and is_inflated == true the method represents an uninflated generic method on an inflated type. */ union { const Il2CppGenericMethod* genericMethod; /* is_inflated is true */ const Il2CppGenericContainer* genericContainer; /* is_inflated is false and is_generic is true */ Il2CppMetadataGenericContainerHandle genericContainerHandle; /* is_inflated is false and is_generic is true */ Il2CppMethodPointer nativeFunction; /* if is_marshaled_from_native is true */ }; uint32_t token; uint16_t flags; uint16_t iflags; uint16_t slot; uint8_t parameters_count; uint8_t is_generic : 1; /* true if method is a generic method definition */ uint8_t is_inflated : 1; /* true if declaring_type is a generic instance or if method is a generic instance*/ uint8_t wrapper_type : 1; /* always zero (MONO_WRAPPER_NONE) needed for the debugger */ uint8_t is_marshaled_from_native : 1; /* a fake MethodInfo wrapping a native function pointer */ void* interpData; Il2CppMethodPointer methodPointerCallByInterp; Il2CppMethodPointer virtualMethodPointerCallByInterp; bool initInterpCallMethodPointer; bool isInterpterImpl; } MethodInfo; 实例方法（instance method）和 静态方法（static method）\n被static修饰的方法为静态方法，之外的方法为实例方法\nvoid staticMethodTest(){ //直接调用静态方法 Boss.work(); //创建实例 Boss boss = new Boss(); //调用实例方法 boss.programming(); } class Boss { String name; public void programming(){ System.out.println(\"I am programming.\"); } public static void work(){ System.out.println(\"I am working.\"); } } AOT和interpreter桥接过程 AOT加载补充元数据原理 为什么需要AOT补充元数据,简单的来讲主要是下面几点\nl2cpp是AOT运行时，它运行时使用的几乎所有（为什么不是全部？）类型都是编译期已经静态确定的。你在AOT中只实例化过List 和 List，在热更新代码中是不能使用类似 new List() 这样的代码的。\n尽管il2cpp可以在内存中创建出List类型的大多数元数据，但它无法创建出它的各个成员函数实现。 你可以通过反射获得typeof(List)，却无法调用它的任何成员函数，包括构造函数。\n无法创建出AOT泛型类型的成员函数实现的本质原因是il2cpp在完成IL到c++代码的转换后，丢失了原始IL函数体信息， 导致无法根据泛型基类List\u003c\u003e的元数据实例化出List的各个成员函数实现。\n泛型类，尤其是泛型容器List、Dictionary之类在代码中使用如此广泛，如果因为AOT限制，导致List之类的都不能运行，那游戏热更新的代码限制也太大了。幸运的是，HybridCLR使用两类技术彻底解决了这个问题：\n基于il2cpp的泛型共享技术[这个技术有局限性和缺陷] [官方用这个技术其实主要还是想用共享机制来减少包体的大小] [优点是节约代码大小，缺点是极大地伤害了泛型函数的性能]\n由于值类型不能泛型共享，泛型实例（类或函数）的泛型参数中如果出现值类型，这个泛型实例必须提前在AOT提前实例化。如果 你的泛型参数类型是热更新代码中定义的值类型，由于热更新类型显然不可能提前在AOT中泛型实例化，导致你在热更新代码 中无法使用 List\u003c热更新值类型\u003e 这样的代码，给开发带来极多的不便。\n基于补充元数据技术，这也是HybridCLR的专利技术[具体源码,原理如下图]\n下载 Hybridclr 工程 下面是我正在阅读的Hybridclr作者初始源码版本 git clone https://gitee.com/focus-creative-games/hybridclr.git -b main git reset --hard 0540b31aa739fd275d8cfcd861cb41568d4a982c 执行上面的命令就能下载到我正在阅读的指定的分支,指定的commit版本\n下面是我加上的对应的注释版本 git clone https://github.com/frog-game/hybridclr-0540b31aa739fd275d8cfcd861cb41568d4a982c.git 执行上面的命令就能下载到我加上的对应的注释版本\nil2cpp_plus工程 下面是我正在阅读的il2cpp_plus作者初始源码版本 git clone -b v2019-1.0.0-rc --depth=1 https://github.com/focus-creative-games/il2cpp_plus.git 执行上面的命令就能下载到我正在阅读的指定的tag版本\n",
  "wordCount" : "5591",
  "inLanguage": "en",
  "image":"https://frog-game.github.io/posts/read/hybridclr-yuanmayuedu/image-20221204163813761.png","datePublished": "2022-12-19T01:30:29+08:00",
  "dateModified": "2022-12-19T01:30:29+08:00",
  "author":[{
    "@type": "Person",
    "name": "frog"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://frog-game.github.io/posts/read/hybridclr-yuanmayuedu/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "frog's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://frog-game.github.io/img/Q.gif"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>



<script async src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>


<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://frog-game.github.io/" accesskey="h" title="frog&#39;s Blog (Alt + H)">
            <img src="https://frog-game.github.io/img/Q.gif" alt="logo" aria-label="logo"
                 height="35">frog&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://frog-game.github.io/search" title="🔍 搜索 (Alt &#43; /)" accesskey=/>
                <span>🔍 搜索</span>
                </a>
            </li>
            <li>
                <a href="https://frog-game.github.io/" title="🏠 主页">
                <span>🏠 主页</span>
                </a>
            </li>
            <li>
                <a href="https://frog-game.github.io/posts" title="📚 文章">
                <span>📚 文章</span>
                </a>
            </li>
            <li>
                <a href="https://frog-game.github.io/tags" title="🧩 标签">
                <span>🧩 标签</span>
                </a>
            </li>
            <li>
                <a href="https://frog-game.github.io/archives/" title="⏱ 时间轴">
                <span>⏱ 时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://frog-game.github.io/about" title="🙋🏻‍♂️ 关于">
                <span>🙋🏻‍♂️ 关于</span>
                </a>
            </li>
            <li>
                <a href="https://frog-game.github.io/links" title="🤝 友链">
                <span>🤝 友链</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main page">
<article class="post-single">
    <div id="single-content">
        <header class="post-header">
            <div class="breadcrumbs"><a href="https://frog-game.github.io/">主页</a>&nbsp;»&nbsp;<a href="https://frog-game.github.io/posts/">📚文章</a>&nbsp;»&nbsp;<a href="https://frog-game.github.io/posts/read/">📕 阅读</a></div>
            <h1 class="post-title">
                HybridCLR-源码阅读
            </h1>
            <div class="post-description">
                对HybridCLR源码的深度阅读,理解,分析,源码进行注释
            </div>
            <div class="post-meta">创建:&nbsp;<span title='2022-12-19 01:30:29 +0800 CST'>2022-12-19</span>&nbsp;|&nbsp;更新:&nbsp;2022-12-19&nbsp;|&nbsp;字数:&nbsp;5591字&nbsp;|&nbsp;时长:&nbsp;12分钟&nbsp;|&nbsp;
作者:&nbsp;frog



                &nbsp;|&nbsp;标签: &nbsp;
                <ul class="post-tags-meta">
                    <a href="https://frog-game.github.io/tags/hybridclr/">HybridCLR</a>
                </ul>

                
                <span id="busuanzi_container_page_pv">
                &nbsp;| 访问: <span id="busuanzi_value_page_pv"></span>
            </span>

</div>
        </header> 
<figure class="entry-cover1"><img loading="lazy" src="https://frog-game.github.io/posts/read/hybridclr-yuanmayuedu/image-20221204163813761.png" alt="">
        
</figure>
        <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">文章目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e4%b8%80%e4%ba%9b%e5%89%8d%e6%8f%90%e7%9f%a5%e8%af%86%e7%82%b9" aria-label="一些前提知识点">一些前提知识点</a><ul>
                        
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e6%9c%af%e8%af%ad%e5%8c%ba%e5%88%ab" aria-label="代码术语区别">代码术语区别</a></li>
                <li>
                    <a href="#%e7%bc%96%e8%af%91%e5%99%a8" aria-label="编译器">编译器</a></li>
                <li>
                    <a href="#%e5%b9%b3%e5%8f%b0%e7%bc%96%e8%af%91" aria-label="平台编译">平台编译</a></li>
                <li>
                    <a href="#%e7%bc%96%e8%af%91%e6%96%b9%e5%bc%8f" aria-label="编译方式">编译方式</a></li>
                <li>
                    <a href="#ios%e4%b8%8d%e6%94%af%e6%8c%81jit%e7%bc%96%e8%af%91%e7%9a%84%e5%8e%9f%e5%9b%a0" aria-label="IOS不支持JIT编译的原因">IOS不支持JIT编译的原因</a></li>
                <li>
                    <a href="#%e5%80%bc%e7%b1%bb%e5%9e%8b%e5%92%8c%e5%bc%95%e7%94%a8%e7%b1%bb%e5%9e%8b" aria-label="值类型和引用类型">值类型和引用类型</a><ul>
                        
                <li>
                    <a href="#%e5%80%bc%e7%b1%bb%e5%9e%8b" aria-label="值类型">值类型</a></li>
                <li>
                    <a href="#%e5%bc%95%e7%94%a8%e7%b1%bb%e5%9e%8b" aria-label="引用类型">引用类型</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%80%bc%e4%bc%a0%e9%80%92%e5%92%8c%e5%bc%95%e7%94%a8%e4%bc%a0%e9%80%92" aria-label="值传递和引用传递">值传递和引用传递</a></li></ul>
                </li>
                <li>
                    <a href="#hybridclr%e8%8f%9c%e5%8d%95" aria-label="HybridCLR菜单">HybridCLR菜单</a></li>
                <li>
                    <a href="#il2cpp" aria-label="IL2CPP">IL2CPP</a><ul>
                        
                <li>
                    <a href="#%e5%88%86%e4%b8%ba%e4%b8%8b%e9%9d%a2%e4%b8%a4%e9%83%a8%e5%88%86" aria-label="分为下面两部分">分为下面两部分</a></li>
                <li>
                    <a href="#%e4%b8%ba%e5%95%a5%e8%a6%81%e8%bd%ac%e6%8d%a2%e6%88%90cpp" aria-label="为啥要转换成CPP">为啥要转换成CPP</a></li>
                <li>
                    <a href="#%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86%e5%b0%b1%e7%9b%b4%e6%8e%a5%e4%b8%8a%e5%ae%98%e7%bd%91%e7%9a%84%e5%9b%be%e4%ba%86" aria-label="工作原理就直接上官网的图了">工作原理就直接上官网的图了</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88il2cpp%e4%b8%8d%e6%94%af%e6%8c%81%e7%83%ad%e6%9b%b4%e6%96%b0" aria-label="为什么IL2CPP不支持热更新">为什么IL2CPP不支持热更新</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%8c%ba%e5%88%ab" aria-label="区别">区别</a></li>
                <li>
                    <a href="#hybridclr%e7%9a%84%e5%8e%9f%e7%90%86" aria-label="Hybridclr的原理">Hybridclr的原理</a></li>
                <li>
                    <a href="#%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90" aria-label="源码解析">源码解析</a><ul>
                        
                <li>
                    <a href="#hybridclr%e5%b7%a5%e7%a8%8b" aria-label="Hybridclr工程">Hybridclr工程</a></li>
                <li>
                    <a href="#%e9%98%85%e8%af%bb%e5%89%8d%e6%8f%90" aria-label="阅读前提">阅读前提</a></li>
                <li>
                    <a href="#aot%e5%92%8cinterpreter%e6%a1%a5%e6%8e%a5%e8%bf%87%e7%a8%8b" aria-label="AOT和interpreter桥接过程">AOT和interpreter桥接过程</a></li>
                <li>
                    <a href="#aot%e5%8a%a0%e8%bd%bd%e8%a1%a5%e5%85%85%e5%85%83%e6%95%b0%e6%8d%ae%e5%8e%9f%e7%90%86" aria-label="AOT加载补充元数据原理">AOT加载补充元数据原理</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%b8%8b%e8%bd%bd" aria-label="下载">下载</a><ul>
                        
                <li>
                    <a href="#hybridclr-%e5%b7%a5%e7%a8%8b" aria-label="Hybridclr 工程">Hybridclr 工程</a></li>
                <li>
                    <a href="#il2cpp_plus%e5%b7%a5%e7%a8%8b" aria-label="il2cpp_plus工程">il2cpp_plus工程</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        
        activeElement = elements[0];
        const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
        document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
    }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 &&
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
            const id = encodeURI(element.getAttribute('id')).toLowerCase();
            if (element === activeElement){
                document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
            } else {
                document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
            }
        })
    }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;
    }
</script>
        
        <div class="post-content"><h2 id="一些前提知识点">一些前提知识点<a hidden class="anchor" aria-hidden="true" href="#一些前提知识点">#</a></h2>
<p><img loading="lazy" src="image-20221204160751223.png" alt="image-20221204160751223"  />
</p>
<h3 id="代码术语区别">代码术语区别<a hidden class="anchor" aria-hidden="true" href="#代码术语区别">#</a></h3>
<ul>
<li>
<p><code>IL</code>:微软平台上的一门中间语言，我们常写的<code>C#</code>代码在编译器中都会自动转换成<code>IL</code>,中间语言是编译使用高级 .NET 语言编写的代码后获得的结果。 对使用其中一种语言编写的代码进行编译后，即可获得 IL 所生成的二进制代码</p>
<p><img loading="lazy" src="image-20221204002617483.png" alt="image-20221204002617483"  />
</p>
</li>
<li>
<p>托管代码：<code>托管代码</code>就是执行过程交由运行时管理的代码。 在这种情况下，相关的运行时称为公共语言运行时 (CLR)，不管使用的是哪种实现（例如 Mono、.NET Framework 或 .NET Core/.NET 5+）。 CLR 负责提取托管代码、将其编译成机器代码，然后执行它。 除此之外，运行时还提供多个重要服务，例如自动内存管理、安全边界、类型安全，把托管代码理解成上面的IL中间语言也行</p>
</li>
<li>
<p>非托管代码：<code>非托管代码</code>（Unmanaged Code）是指直接编译成目标计算机的机器码，这些代码只能运行在编译出这些代码的计算机上，或者是其他相同处理器或者几乎一样处理器的计算机上。<code>非托管代码</code>不能享受公共语言运行库所提供的一些服务，例如内存管理、安全管理等。<code>非托管代码</code>（Unmanaged Code）不由CLR公共语言运行库执行，而是由操作系统直接执行的代码,如果非托管代码需要进行内存管理等服务，就必须显式地调用操作系统的接口，通常非托管代码调用Windows SDK所提供的API来实现内存管理。</p>
</li>
<li>
<p>原生代码:<code>native code</code>是本地<code>cpu</code>的目标执行代码, 不是<code>IL</code>, 所以速度很快, 它的执行不依赖某个虚拟机或者解释器，编译后可直接依附操作系统运行，不需要经过虚拟机之类的东西</p>
</li>
<li>
<p>程序集:程序集（Assembly）的文件负责封装中间语言，程序集中包含了描述所创建的方法、类以及属性的所有元数据</p>
</li>
</ul>
<h3 id="编译器">编译器<a hidden class="anchor" aria-hidden="true" href="#编译器">#</a></h3>
<ul>
<li>c#编译器: 将<code>c#</code>编译为<code>IL</code> <code>[C#----&gt;CIL]</code></li>
<li>Mono Runtime编译器:将<code>IL</code>转换成原生码，然后让<code>Mono</code>运行时去执行,这样其实也达到了<code>c#</code>跨平台的效果</li>
</ul>
<h3 id="平台编译">平台编译<a hidden class="anchor" aria-hidden="true" href="#平台编译">#</a></h3>
<p><strong>build</strong></p>
<p><strong><code>编译GCC的平台</code></strong></p>
<p><strong>host</strong></p>
<p><strong><code>运行GCC的平台</code></strong></p>
<p><strong>target</strong></p>
<p><strong><code>GCC编译产生的应用程序的运行平台</code></strong></p>
<ul>
<li>native compiler:三者全部相同（build = host = target）就是<code>原生编译</code> 我们在PC上装的Ubuntu或者Fedora里面带的GCC，就是native compiler</li>
<li>cross compile:如果build = host，但是target跟前两者不同就是 <code>交叉编译</code>开发手机应用程序的编译器，通常运行在PC或Mac上，但是编译出来的程序无法直接在PC或Mac上执行</li>
</ul>
<h3 id="编译方式">编译方式<a hidden class="anchor" aria-hidden="true" href="#编译方式">#</a></h3>
<ul>
<li>即时编译[<strong><code>Just in time, JIT</code></strong>]: 就是在程序运行的时候把CIL的byte code 转成目标平台的原生码,也就是Mono Runtime编译器干的活</li>
<li>提前编译[<strong><code>Ahead of time,AOT</code></strong>]:程序运行前将exe或者dll里面的CIL的byte code部分转成目标平台的原生码,并且存储起来，好加快速度,但是程序中还是会有部分的CIL的byte code需要JIT编译</li>
<li>完全静态编译[<strong><code>Full ahead of time,Full-AOT</code></strong>]:就是将所有源码编译成目标平台所需要的原生码</li>
</ul>
<h3 id="ios不支持jit编译的原因">IOS不支持JIT编译的原因<a hidden class="anchor" aria-hidden="true" href="#ios不支持jit编译的原因">#</a></h3>
<ul>
<li>IOS并非把JIT禁止了，主要还是IOS封存了内存的[<code>可执行权限</code>]，变相的封锁了JIT编译方式</li>
</ul>
<h3 id="值类型和引用类型">值类型和引用类型<a hidden class="anchor" aria-hidden="true" href="#值类型和引用类型">#</a></h3>
<p>C# 中的类型一共分为两类，一类是值类型(Value Type)，一类是引用类型(Reference Type)。</p>
<blockquote>
<p>值类型包括结构体(<code>struct</code>)和枚举(<code>enum</code>)。
引用类型包括类(<code>class</code>)、接口(<code>interface</code>)、委托(<code>delegate</code>)、数组(<code>array</code>)等。</p>
<p>常见的简单类型如<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code>、<code>double</code>、<code>byte</code>、<code>char</code>等其本质上都是结构体，对应<code>struct System.Int16</code>、<code>System.Int32</code>、<code>System.Int64</code>、<code>System.Single</code>、<code>System.Double</code>、<code>Syetem.Byte</code>、<code>System.Char</code>，因此它们都是值类型。但<code>string</code>和<code>object</code>例外，它们本质上是类，对应<code>class System.String</code>和<code>System.Object</code>，所以它们是引用类型。</p>
</blockquote>
<h4 id="值类型">值类型<a hidden class="anchor" aria-hidden="true" href="#值类型">#</a></h4>
<p>值类型变量本身保存了该类型的全部数据，当声明一个值类型的变量时，该变量会被分配到栈(Stack)上。</p>
<h4 id="引用类型">引用类型<a hidden class="anchor" aria-hidden="true" href="#引用类型">#</a></h4>
<p>引用类型变量本身保存的是位于堆(Heap)上的该类型的实例的内存地址，并不包含数据。当声明一个引用类型变量时，该变量会被分配到栈上。如果仅仅只是声明这样一个变量，由于在堆上还没有创建该类型的实例，因此，变量值为null，意思是不指向任何类型实例(堆上的对象)。对于变量的类型声明，用于限制此变量可以保存的类型。</p>
<h3 id="值传递和引用传递">值传递和引用传递<a hidden class="anchor" aria-hidden="true" href="#值传递和引用传递">#</a></h3>
<p>C#中方法的参数传递默认的是值传递，引用传递和输出传递需要在参数类型前面对应加上ref、out限制符，由于输出传递和引用传递类似，这里只讨论引用传递。</p>
<p>值传递参数是原变量的拷贝，值传递参数和原变量的内存地址不同，因此方法中对值传递参数的修改不会改变原变量。</p>
<p>引用传递参数是原变量的指针，引用传递参数和原变量的内存地址相同，相应的方法中对引用传递参数的修改会改变原变量。</p>
<h2 id="hybridclr菜单">HybridCLR菜单<a hidden class="anchor" aria-hidden="true" href="#hybridclr菜单">#</a></h2>
<p><img loading="lazy" src="image-20221211000613359.png" alt="image-20221211000613359"  />
</p>
<h2 id="il2cpp">IL2CPP<a hidden class="anchor" aria-hidden="true" href="#il2cpp">#</a></h2>
<p>就是上面的<code>2.1编译方式</code>中的AOT提前编译</p>
<h3 id="分为下面两部分">分为下面两部分<a hidden class="anchor" aria-hidden="true" href="#分为下面两部分">#</a></h3>
<ol>
<li>AOT编译器</li>
</ol>
<p>​		把IL中间语言转成CPP文件的作用</p>
<ol start="2">
<li>运行时库</li>
</ol>
<p>​		主要是做垃圾回收,线程文件的获取，还有对托管数据的原生代码进行修改</p>
<h3 id="为啥要转换成cpp">为啥要转换成CPP<a hidden class="anchor" aria-hidden="true" href="#为啥要转换成cpp">#</a></h3>
<ol>
<li>运行速度快,这个毋庸置疑</li>
<li>mono 为了跨平台，他是通过VM来实现的，也就是说有几个平台，就需要实现几个VM,这种方法耗时耗力,而且为了实现各个平台的支持和移植，势必要把代码进行修改，然后出现bug在进行修复，来来回回时间和精力花费不少，所以为啥不利用现成各个平台的C++编译器执行了,这也是IL2CPP的核心思想</li>
<li>虽然最后代码都变成的静态的C++但是内存管理这块还是需要遵循c#的标准和方式,这也是为什么最后还需要一个 IL2CPP VM的原因 这个时候VM做得主要还是GC的管理,线程的创建等等一些辅助服务性的工作</li>
</ol>
<h3 id="工作原理就直接上官网的图了">工作原理就直接上官网的图了<a hidden class="anchor" aria-hidden="true" href="#工作原理就直接上官网的图了">#</a></h3>
<p><img loading="lazy" src="image-20221203100515921.png" alt="image-20221203100515921"  />
</p>
<p><img loading="lazy" src="image-20221204163051027.png" alt="image-20221204163051027"  />
</p>
<h3 id="为什么il2cpp不支持热更新">为什么IL2CPP不支持热更新<a hidden class="anchor" aria-hidden="true" href="#为什么il2cpp不支持热更新">#</a></h3>
<p>因为IL2CPP是一个纯静态的AOT运行时，然后不支持运行时加载DLL，所以是不支持热更新</p>
<p>然后hybridclr扩充了IL2CPP的代码,使他从AOT运行方式变成了AOT+Interpreter的混合方式从而可以动态的加载dll实现热更新</p>
<h2 id="区别">区别<a hidden class="anchor" aria-hidden="true" href="#区别">#</a></h2>
<p>原始IL指令集是基于栈的指令集</p>
<p>Hybridclr是基于寄存器指令</p>
<p>两种方式各有优缺点，基于栈的指令集很明显可移植高，但是工作效率较低。而基于寄存器指令集寄存器由硬件直接提供，工作效率高，程序受硬件约束。</p>
<h2 id="hybridclr的原理">Hybridclr的原理<a hidden class="anchor" aria-hidden="true" href="#hybridclr的原理">#</a></h2>
<p>dll不过是元数据和代码的集合,aot与 热更新dll的区别只不过一个函数以aot代码方式执行，一个以解释方式执行,最后都会直接在虚拟机层面将aot和热更新dll统一对待</p>
<p>为什么Hybridclr能做到如此统一和彻底，因为元数据不过是数据，不管aot还是热更新是没有本质区别的</p>
<p>而托管代码执行，依赖的不过是代码和数据</p>
<p>Hybridclr分两个工程</p>
<ol>
<li>
<p>Hybridclr工程进行了源码的编译解析，在这里可以理解成这个工程做得主要事情是解释器的工作,此解释器是在IL2CPP VM扩充的，不解的可以看下图</p>
</li>
<li>
<p>第二个工程是il2cpp_plus,这个工程会把泛型方法、泛型数据类型、以及其他的一些支持添加到IL2CPP里面,也可以简单的理解成为主要是为了给IL2CPP扩展功能用的，从而能让他动态的加载DLL</p>
<p><img loading="lazy" src="image-20221204163813761.png" alt="image-20221204163813761"  />
</p>
</li>
</ol>
<h2 id="源码解析">源码解析<a hidden class="anchor" aria-hidden="true" href="#源码解析">#</a></h2>
<h3 id="hybridclr工程">Hybridclr工程<a hidden class="anchor" aria-hidden="true" href="#hybridclr工程">#</a></h3>
<p>这个是代码工程结构</p>
<p><img loading="lazy" src="image-20221219135252413.png" alt="image-20221219135252413"  />
</p>
<h3 id="阅读前提">阅读前提<a hidden class="anchor" aria-hidden="true" href="#阅读前提">#</a></h3>
<ol>
<li>
<p><code>ARM64</code>:CPU的ARM架构 主流的手机/平板品牌，绝大数是采用ARM架构</p>
</li>
<li>
<p><code>BoehmGC</code>算法，unity底层托管堆使用的是BoehmGC算法是用的mark-sweep（标记-清扫）算法,具体和Java的gc算法类型,这块由于篇幅问题就不详细写了,太多内容一句话说不清楚,以后有时间整理一篇详细文章出来</p>
</li>
<li>
<p><code>Module</code> 是 .dll 或 .exe 类型的可移植可执行文件，这些文件由一个或多个类和接口组成</p>
</li>
<li>
<p><code>Assembly</code> 是程序集</p>
</li>
<li>
<p><code>Assembly</code>有<code>main</code>程序函数。<code>module</code>只能附属于程序集，程序集可以拥有多个。</p>
</li>
<li>
<p><code>MetaData</code>就是用<code>System.reflection</code>得到的方法，属性，参数等等，这些都是**<code>元数据</code>**</p>
</li>
<li>
<p><code>MethodBody</code> 方法主体，就是**<code>调用方法时执行的代码块</code>**，方法的主体语句必须放在花括号（即大括号 {}）中。</p>
</li>
<li>
<p><code>Il2CppImage</code> 这个结构体是程序集镜像,可以通过它来获取命名空间,class,方法,函数指针地址等等</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Il2CppImage</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> name;<span style="color:#75715e">//名字
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>nameNoExt;<span style="color:#75715e">//扩展名字
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Il2CppAssembly<span style="color:#f92672">*</span> assembly;<span style="color:#75715e">//程序集指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    TypeDefinitionIndex typeStart;<span style="color:#75715e">//方法类型偏移位置开始
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint32_t</span> typeCount;<span style="color:#75715e">//方法总数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    TypeDefinitionIndex exportedTypeStart;<span style="color:#75715e">//导出类型偏移位置开始
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint32_t</span> exportedTypeCount;<span style="color:#75715e">//导出类型总数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    CustomAttributeIndex customAttributeStart;<span style="color:#75715e">//自定义属性偏移位置开始
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint32_t</span> customAttributeCount;<span style="color:#75715e">//自定义属性总数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    MethodIndex entryPointIndex;<span style="color:#75715e">//方法入口点索引
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef __cplusplus
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">mutable</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Il2CppNameToTypeDefinitionIndexHashTable <span style="color:#f92672">*</span> nameToClassHashTable;<span style="color:#75715e">//name对应的class的hashTable
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> Il2CppCodeGenModule<span style="color:#f92672">*</span> codeGenModule;<span style="color:#75715e">//Module指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> token;<span style="color:#75715e">//通过他可以得到函数指针地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint8_t</span> dynamic;<span style="color:#75715e">//没看到使用,估计是用来验证是不是动态lib使用的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} Il2CppImage;
</span></span></code></pre></div></li>
<li>
<p>所有的<code>metadata</code> 解析都是遵循的下面规范<a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-335/">ECMA-335 - Ecma International (ecma-international.org)</a></p>
<p>CLI中大多数<code>metadata</code>被为几十种类型，每个类型的数据组织成一个<code>table</code>如下图,如果有缺失类型,请去<code>ECMA-335</code>查看</p>
<p><img loading="lazy" src="image-20221210204108400.png" alt="image-20221210204108400"  />
</p>
</li>
<li>
<p><code>Portable PDB tables</code> .NET引入了一种新的符号文件（PDB）格式，主要用于跨平台</p>
<p>早期<code>PDB</code>格式是为了<code>C</code>和<code>C++</code>设计的，发展了多年以来现在已经支持<code>.NET</code>了。不幸的是，这种格式一直以来都被认为是专有的，这就意味着它没有很好文档记录，而且只能使用<code>Windows</code>库读取，所以有了<code>.NET Core</code>，而且为了跨平台，于是开发了这个新的跨平台<code>PDB</code>库</p>
</li>
<li>
<p>原始 MethodInfo</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MethodInfo</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Il2CppMethodPointer methodPointer;<span style="color:#75715e">//指向普通执行函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    InvokerMethod invoker_method;<span style="color:#75715e">//指向反射执行函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> name;<span style="color:#75715e">//名字
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Il2CppClass <span style="color:#f92672">*</span>klass;<span style="color:#75715e">//函数所属类指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> Il2CppType <span style="color:#f92672">*</span>return_type;<span style="color:#75715e">//返回值类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> ParameterInfo<span style="color:#f92672">*</span> parameters;<span style="color:#75715e">//参数信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">union</span><span style="color:#960050;background-color:#1e0010">//</span><span style="color:#a6e22e">generic</span> instance method 
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> Il2CppRGCTXData<span style="color:#f92672">*</span> rgctx_data; <span style="color:#75715e">/* is_inflated is true and is_generic is false, i.e. a generic instance method */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> Il2CppMethodDefinition<span style="color:#f92672">*</span> methodDefinition;<span style="color:#75715e">//方法定义
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">union</span><span style="color:#960050;background-color:#1e0010">//</span><span style="color:#a6e22e">uninflated</span> generic method 
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> Il2CppGenericMethod<span style="color:#f92672">*</span> genericMethod; <span style="color:#75715e">/* is_inflated is true */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> Il2CppGenericContainer<span style="color:#f92672">*</span> genericContainer; <span style="color:#75715e">/* is_inflated is false and is_generic is true */</span>
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> token;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint16_t</span> flags;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint16_t</span> iflags;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint16_t</span> slot;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint8_t</span> parameters_count;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint8_t</span> is_generic : <span style="color:#ae81ff">1</span>; <span style="color:#75715e">/* true if method is a generic method definition */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint8_t</span> is_inflated : <span style="color:#ae81ff">1</span>; <span style="color:#75715e">/* true if declaring_type is a generic instance or if method is a generic instance*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint8_t</span> wrapper_type : <span style="color:#ae81ff">1</span>; <span style="color:#75715e">/* always zero (MONO_WRAPPER_NONE) needed for the debugger */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint8_t</span> is_marshaled_from_native : <span style="color:#ae81ff">1</span>; <span style="color:#75715e">/* a fake MethodInfo wrapping a native function pointer */</span>
</span></span><span style="display:flex;"><span>} MethodInfo;
</span></span></code></pre></div></li>
<li>
<p>改写后的MethodInfo</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MethodInfo</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Il2CppMethodPointer methodPointer;
</span></span><span style="display:flex;"><span>    InvokerMethod invoker_method;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> name;
</span></span><span style="display:flex;"><span>    Il2CppClass <span style="color:#f92672">*</span>klass;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> Il2CppType <span style="color:#f92672">*</span>return_type;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> ParameterInfo<span style="color:#f92672">*</span> parameters;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">union</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> Il2CppRGCTXData<span style="color:#f92672">*</span> rgctx_data; <span style="color:#75715e">/* is_inflated is true and is_generic is false, i.e. a generic instance method */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> Il2CppMethodDefinition<span style="color:#f92672">*</span> methodDefinition;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> Il2CppMethodDefinition<span style="color:#f92672">*</span> methodMetadataHandle;
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* note, when is_generic == true and is_inflated == true the method represents an uninflated generic method on an inflated type. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">union</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> Il2CppGenericMethod<span style="color:#f92672">*</span> genericMethod; <span style="color:#75715e">/* is_inflated is true */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> Il2CppGenericContainer<span style="color:#f92672">*</span> genericContainer; <span style="color:#75715e">/* is_inflated is false and is_generic is true */</span>
</span></span><span style="display:flex;"><span>        Il2CppMetadataGenericContainerHandle genericContainerHandle; <span style="color:#75715e">/* is_inflated is false and is_generic is true */</span>
</span></span><span style="display:flex;"><span>        Il2CppMethodPointer nativeFunction; <span style="color:#75715e">/* if is_marshaled_from_native is true */</span>
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> token;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint16_t</span> flags;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint16_t</span> iflags;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint16_t</span> slot;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint8_t</span> parameters_count;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint8_t</span> is_generic : <span style="color:#ae81ff">1</span>; <span style="color:#75715e">/* true if method is a generic method definition */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint8_t</span> is_inflated : <span style="color:#ae81ff">1</span>; <span style="color:#75715e">/* true if declaring_type is a generic instance or if method is a generic instance*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint8_t</span> wrapper_type : <span style="color:#ae81ff">1</span>; <span style="color:#75715e">/* always zero (MONO_WRAPPER_NONE) needed for the debugger */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint8_t</span> is_marshaled_from_native : <span style="color:#ae81ff">1</span>; <span style="color:#75715e">/* a fake MethodInfo wrapping a native function pointer */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> interpData;
</span></span><span style="display:flex;"><span>    Il2CppMethodPointer methodPointerCallByInterp;
</span></span><span style="display:flex;"><span>    Il2CppMethodPointer virtualMethodPointerCallByInterp;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> initInterpCallMethodPointer;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> isInterpterImpl;
</span></span><span style="display:flex;"><span>} MethodInfo;
</span></span></code></pre></div></li>
<li>
<p><code>实例方法</code>（instance method）和 <code>静态方法</code>（static method）</p>
<p>被static修饰的方法为<code>静态方法</code>，之外的方法为<code>实例方法</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> staticMethodTest(){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//直接调用静态方法</span>
</span></span><span style="display:flex;"><span>    Boss.work();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//创建实例</span>
</span></span><span style="display:flex;"><span>    Boss boss = <span style="color:#66d9ef">new</span> Boss();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//调用实例方法</span>
</span></span><span style="display:flex;"><span>    boss.programming();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Boss</span> {
</span></span><span style="display:flex;"><span>    String name;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> programming(){
</span></span><span style="display:flex;"><span>        System.<span style="color:#66d9ef">out</span>.println(<span style="color:#e6db74">&#34;I am programming.&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> work(){
</span></span><span style="display:flex;"><span>        System.<span style="color:#66d9ef">out</span>.println(<span style="color:#e6db74">&#34;I am working.&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ol>
<h3 id="aot和interpreter桥接过程">AOT和interpreter桥接过程<a hidden class="anchor" aria-hidden="true" href="#aot和interpreter桥接过程">#</a></h3>
<p><img loading="lazy" src="hybridclr-%e6%a1%a5%e6%8e%a5%e9%80%bb%e8%be%91-16705923093584.png" alt="img"  />
</p>
<h3 id="aot加载补充元数据原理">AOT加载补充元数据原理<a hidden class="anchor" aria-hidden="true" href="#aot加载补充元数据原理">#</a></h3>
<p>为什么需要AOT补充元数据,简单的来讲主要是下面几点</p>
<p>l2cpp是AOT运行时，它运行时使用的几乎所有（为什么不是全部？）类型都是编译期已经静态确定的。你在AOT中只实例化过<code>List&lt;int&gt;</code> 和 <code>List&lt;string&gt;</code>，在热更新代码中是不能使用类似 <code>new List&lt;float&gt;()</code> 这样的代码的。</p>
<p>尽管il2cpp可以在内存中创建出<code>List&lt;float&gt;</code>类型的大多数元数据，但它无法创建出它的各个成员函数实现。 你可以通过反射获得<code>typeof(List&lt;float&gt;)</code>，却无法调用它的任何成员函数，包括构造函数。</p>
<p>无法创建出AOT泛型类型的成员函数实现的本质原因是il2cpp在完成IL到c++代码的转换后，丢失了原始IL函数体信息， 导致无法根据泛型基类<code>List&lt;&gt;</code>的元数据实例化出<code>List&lt;float&gt;</code>的各个成员函数实现。</p>
<p>泛型类，尤其是泛型容器List、Dictionary之类在代码中使用如此广泛，如果因为AOT限制，导致List<HotUpdateType>之类的都不能运行，那游戏热更新的代码限制也太大了。幸运的是，HybridCLR使用两类技术彻底解决了这个问题：</p>
<ul>
<li>
<p>基于il2cpp的<code>泛型共享</code>技术[<strong><code>这个技术有局限性和缺陷</code></strong>] [<strong><code>官方用这个技术其实主要还是想用共享机制来减少包体的大小</code></strong>] [<strong><code>优点是节约代码大小，缺点是极大地伤害了泛型函数的性能</code></strong>]</p>
<p>由于值类型不能泛型共享，泛型实例（类或函数）的泛型参数中如果出现值类型，这个泛型实例必须提前在AOT提前实例化。如果 你的泛型参数类型是热更新代码中定义的值类型，由于热更新类型显然不可能提前在AOT中泛型实例化，导致你在热更新代码 中无法使用 <code>List&lt;热更新值类型&gt;</code> 这样的代码，给开发带来极多的不便。</p>
</li>
<li>
<p>基于<code>补充元数据</code>技术，这也是<code>HybridCLR</code>的专利技术[具体源码,原理如下图]</p>
</li>
</ul>
<p><img loading="lazy" src="hybridclr-AOT%e5%8a%a0%e8%bd%bd%e5%85%83%e6%95%b0%e6%8d%ae%e5%8e%9f%e7%90%86.png" alt="img"  />
</p>
<h2 id="下载">下载<a hidden class="anchor" aria-hidden="true" href="#下载">#</a></h2>
<h3 id="hybridclr-工程">Hybridclr 工程<a hidden class="anchor" aria-hidden="true" href="#hybridclr-工程">#</a></h3>
<ul>
<li>下面是我正在阅读的Hybridclr作者初始源码版本</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>git clone  https://gitee.com/focus-creative-games/hybridclr.git  -b main
</span></span><span style="display:flex;"><span>git reset --hard 0540b31aa739fd275d8cfcd861cb41568d4a982c
</span></span></code></pre></div><p><code>执行上面的命令就能下载到我正在阅读的指定的分支,指定的commit版本</code></p>
<ul>
<li>下面是我加上的对应的注释版本</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>git clone https://github.com/frog-game/hybridclr-0540b31aa739fd275d8cfcd861cb41568d4a982c.git
</span></span></code></pre></div><p><code>执行上面的命令就能下载到我加上的对应的注释版本</code></p>
<h3 id="il2cpp_plus工程">il2cpp_plus工程<a hidden class="anchor" aria-hidden="true" href="#il2cpp_plus工程">#</a></h3>
<ul>
<li>下面是我正在阅读的il2cpp_plus作者初始源码版本</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>git clone -b v2019-1.0.0-rc --depth<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> https://github.com/focus-creative-games/il2cpp_plus.git
</span></span></code></pre></div><p><code>执行上面的命令就能下载到我正在阅读的指定的tag版本</code></p>


        </div>
        <div class="post-reward">
            <div style="padding: 0 0 0 0; margin: 0 0 0 0; width: 100%; font-size:16px; text-align: center;">
                <div id="QR" style="opacity: 0;">
                    <div id="wechat" style="display: inline-block">
                        <a class="fancybox" rel="group">
                            <img id="wechat_qr" src="https://frog-game.github.io/img/wechat_pay.png" alt="wechat_pay"></a>
                        <p>微信</p>
                    </div>
                    <div id="alipay" style="display: inline-block">
                        <a class="fancybox" rel="group">
                            <img id="alipay_qr" src="https://frog-game.github.io/img/alipay_pay.png" alt="alipay"></a>
                        <p>支付宝</p>
                    </div>
                </div>
                <button id="rewardButton"
                        onclick="
                    var qr = document.getElementById('QR');
                    if (qr.style.opacity === '0') {
                        qr.style.opacity='1';
                    } else {
                        qr.style.opacity='0'
                    }"
                >
                    <span>🧧 鼓励</span>
                </button>
            </div>
        </div>

        <footer class="post-footer">
            
<nav class="paginav">
  <a class="prev" href="https://frog-game.github.io/posts/blog/hybridclr-ios-dabao/">
    <span class="title">« 上一页</span>
    <br>
    <span>HybridCLR-IOS-打包-热更新</span>
  </a>
  <a class="next" href="https://frog-game.github.io/posts/blog/aoi-tower/">
    <span class="title">下一页 »</span>
    <br>
    <span>四叉树Lod灯塔AOI</span>
  </a>
</nav>

        </footer>
    </div>



<div>
    <div class="pagination__title">
        <span class="pagination__title-h" style="font-size: 20px;">💬评论</span>
        <hr />
    </div>

    <div id="tcomment"></div>

    <script src="https://cdn.staticfile.org/twikoo/1.6.7/twikoo.all.min.js">
    </script>
    

    

    <script>
        twikoo.init({
            envId: "https://www.frog-game.work/", 
            el: "#tcomment",
            lang: 'zh-CN',
            region: "ap-beijing",
            path: window.TWIKOO_MAGIC_PATH||window.location.pathname,
            
            
            
            
            
            
            
        });
    </script>

</div>
</article>
</main>


<script async src="https://unpkg.com/mermaid@8.8.1/dist/mermaid.min.js"></script>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<footer class="footer">
    <span>
        Copyright
        &copy;
        2020-2022 
        <a href="https://frog-game.github.io/" style="color:#939393;">frog&#39;s Blog</a>
         All Rights Reserved
    </span>

    <a href="https://beian.miit.gov.cn/" target="_blank" style="color:#939393;">备案号</a>&nbsp;

    <span>
        <a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=null"style="display:inline-block;text-decoration:none;height:20px;color:#939393;">
            <img src="https://frog-game.github.io/img/beian.png" style="float:left;margin: 0px 5px 0px 0px;"/>
            公网安备
        </a>
    </span>

    <span id="busuanzi_container">
        <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
        总访客数: <span id="busuanzi_value_site_uv"></span>
        总访问量: <span id="busuanzi_value_site_pv"></span>
    </span>
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <span class="topInner">
        <svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z"/>
        </svg>
        <span id="read_progress"></span>
    </span>
</a>

<script>
    document.addEventListener('scroll', function (e) {
        const readProgress = document.getElementById("read_progress");
        const scrollHeight = document.documentElement.scrollHeight;
        const clientHeight = document.documentElement.clientHeight;
        const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        
        readProgress.innerText = ((scrollTop / (scrollHeight - clientHeight)).toFixed(2) * 100).toFixed(0);
    })
</script>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 400 || document.documentElement.scrollTop > 400) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>

<script>
    document.body.addEventListener('copy', function (e) {
        if (window.getSelection().toString() && window.getSelection().toString().length > 50) {
            let clipboardData = e.clipboardData || window.clipboardData;
            if (clipboardData) {
                e.preventDefault();
                let htmlData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"frog's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                    '\r\n原文链接：' + location.href;
                let textData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"frog's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                    '\r\n原文链接：' + location.href;
                clipboardData.setData('text/html', htmlData);
                clipboardData.setData('text/plain', textData);
            }
        }
    });
</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = '📄复制';

        function copyingDone() {
            copybutton.innerText = '👌🏻已复制!';
            setTimeout(() => {
                copybutton.innerText = '📄复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                let text = codeblock.textContent +
                    '\r\n————————————————\r\n' +
                    '版权声明：本文为「'+"frog's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                    '\r\n原文链接：' + location.href;
                navigator.clipboard.writeText(text);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) {
            }
            ;
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
